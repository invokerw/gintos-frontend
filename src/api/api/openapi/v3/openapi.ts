// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.14.0
// source: openapi/v3/openapi.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any as Any1 } from "../../google/protobuf/any";

export const protobufPackage = "openapi.v3";

export interface AdditionalPropertiesItem {
  schemaOrReference?: SchemaOrReference | undefined;
  boolean?: boolean | undefined;
}

export interface Any {
  value: Any1 | undefined;
  yaml: string;
}

export interface AnyOrExpression {
  any?: Any | undefined;
  expression?: Expression | undefined;
}

/** A map of possible out-of band callbacks related to the parent operation. Each value in the map is a Path Item Object that describes a set of requests that may be initiated by the API provider and the expected responses. The key value used to identify the callback object is an expression, evaluated at runtime, that identifies a URL to use for the callback operation. */
export interface Callback {
  path: NamedPathItem[];
  specificationExtension: NamedAny[];
}

export interface CallbackOrReference {
  callback?: Callback | undefined;
  reference?: Reference | undefined;
}

export interface CallbacksOrReferences {
  additionalProperties: NamedCallbackOrReference[];
}

/** Holds a set of reusable objects for different aspects of the OAS. All objects defined within the components object will have no effect on the API unless they are explicitly referenced from properties outside the components object. */
export interface Components {
  schemas: SchemasOrReferences | undefined;
  responses: ResponsesOrReferences | undefined;
  parameters: ParametersOrReferences | undefined;
  examples: ExamplesOrReferences | undefined;
  requestBodies: RequestBodiesOrReferences | undefined;
  headers: HeadersOrReferences | undefined;
  securitySchemes: SecuritySchemesOrReferences | undefined;
  links: LinksOrReferences | undefined;
  callbacks: CallbacksOrReferences | undefined;
  specificationExtension: NamedAny[];
}

/** Contact information for the exposed API. */
export interface Contact {
  name: string;
  url: string;
  email: string;
  specificationExtension: NamedAny[];
}

export interface DefaultType {
  number?: number | undefined;
  boolean?: boolean | undefined;
  string?: string | undefined;
}

/** When request bodies or response payloads may be one of a number of different schemas, a `discriminator` object can be used to aid in serialization, deserialization, and validation.  The discriminator is a specific object in a schema which is used to inform the consumer of the specification of an alternative schema based on the value associated with it.  When using the discriminator, _inline_ schemas will not be considered. */
export interface Discriminator {
  propertyName: string;
  mapping: Strings | undefined;
  specificationExtension: NamedAny[];
}

export interface Document {
  openapi: string;
  info: Info | undefined;
  servers: Server[];
  paths: Paths | undefined;
  components: Components | undefined;
  security: SecurityRequirement[];
  tags: Tag[];
  externalDocs: ExternalDocs | undefined;
  specificationExtension: NamedAny[];
}

/** A single encoding definition applied to a single schema property. */
export interface Encoding {
  contentType: string;
  headers: HeadersOrReferences | undefined;
  style: string;
  explode: boolean;
  allowReserved: boolean;
  specificationExtension: NamedAny[];
}

export interface Encodings {
  additionalProperties: NamedEncoding[];
}

export interface Example {
  summary: string;
  description: string;
  value: Any | undefined;
  externalValue: string;
  specificationExtension: NamedAny[];
}

export interface ExampleOrReference {
  example?: Example | undefined;
  reference?: Reference | undefined;
}

export interface ExamplesOrReferences {
  additionalProperties: NamedExampleOrReference[];
}

export interface Expression {
  additionalProperties: NamedAny[];
}

/** Allows referencing an external resource for extended documentation. */
export interface ExternalDocs {
  description: string;
  url: string;
  specificationExtension: NamedAny[];
}

/** The Header Object follows the structure of the Parameter Object with the following changes:  1. `name` MUST NOT be specified, it is given in the corresponding `headers` map. 1. `in` MUST NOT be specified, it is implicitly in `header`. 1. All traits that are affected by the location MUST be applicable to a location of `header` (for example, `style`). */
export interface Header {
  description: string;
  required: boolean;
  deprecated: boolean;
  allowEmptyValue: boolean;
  style: string;
  explode: boolean;
  allowReserved: boolean;
  schema: SchemaOrReference | undefined;
  example: Any | undefined;
  examples: ExamplesOrReferences | undefined;
  content: MediaTypes | undefined;
  specificationExtension: NamedAny[];
}

export interface HeaderOrReference {
  header?: Header | undefined;
  reference?: Reference | undefined;
}

export interface HeadersOrReferences {
  additionalProperties: NamedHeaderOrReference[];
}

/** The object provides metadata about the API. The metadata MAY be used by the clients if needed, and MAY be presented in editing or documentation generation tools for convenience. */
export interface Info {
  title: string;
  description: string;
  termsOfService: string;
  contact: Contact | undefined;
  license: License | undefined;
  version: string;
  specificationExtension: NamedAny[];
  summary: string;
}

export interface ItemsItem {
  schemaOrReference: SchemaOrReference[];
}

/** License information for the exposed API. */
export interface License {
  name: string;
  url: string;
  specificationExtension: NamedAny[];
}

/** The `Link object` represents a possible design-time link for a response. The presence of a link does not guarantee the caller's ability to successfully invoke it, rather it provides a known relationship and traversal mechanism between responses and other operations.  Unlike _dynamic_ links (i.e. links provided **in** the response payload), the OAS linking mechanism does not require link information in the runtime response.  For computing links, and providing instructions to execute them, a runtime expression is used for accessing values in an operation and using them as parameters while invoking the linked operation. */
export interface Link {
  operationRef: string;
  operationId: string;
  parameters: AnyOrExpression | undefined;
  requestBody: AnyOrExpression | undefined;
  description: string;
  server: Server | undefined;
  specificationExtension: NamedAny[];
}

export interface LinkOrReference {
  link?: Link | undefined;
  reference?: Reference | undefined;
}

export interface LinksOrReferences {
  additionalProperties: NamedLinkOrReference[];
}

/** Each Media Type Object provides schema and examples for the media type identified by its key. */
export interface MediaType {
  schema: SchemaOrReference | undefined;
  example: Any | undefined;
  examples: ExamplesOrReferences | undefined;
  encoding: Encodings | undefined;
  specificationExtension: NamedAny[];
}

export interface MediaTypes {
  additionalProperties: NamedMediaType[];
}

/** Automatically-generated message used to represent maps of Any as ordered (name,value) pairs. */
export interface NamedAny {
  /** Map key */
  name: string;
  /** Mapped value */
  value: Any | undefined;
}

/** Automatically-generated message used to represent maps of CallbackOrReference as ordered (name,value) pairs. */
export interface NamedCallbackOrReference {
  /** Map key */
  name: string;
  /** Mapped value */
  value: CallbackOrReference | undefined;
}

/** Automatically-generated message used to represent maps of Encoding as ordered (name,value) pairs. */
export interface NamedEncoding {
  /** Map key */
  name: string;
  /** Mapped value */
  value: Encoding | undefined;
}

/** Automatically-generated message used to represent maps of ExampleOrReference as ordered (name,value) pairs. */
export interface NamedExampleOrReference {
  /** Map key */
  name: string;
  /** Mapped value */
  value: ExampleOrReference | undefined;
}

/** Automatically-generated message used to represent maps of HeaderOrReference as ordered (name,value) pairs. */
export interface NamedHeaderOrReference {
  /** Map key */
  name: string;
  /** Mapped value */
  value: HeaderOrReference | undefined;
}

/** Automatically-generated message used to represent maps of LinkOrReference as ordered (name,value) pairs. */
export interface NamedLinkOrReference {
  /** Map key */
  name: string;
  /** Mapped value */
  value: LinkOrReference | undefined;
}

/** Automatically-generated message used to represent maps of MediaType as ordered (name,value) pairs. */
export interface NamedMediaType {
  /** Map key */
  name: string;
  /** Mapped value */
  value: MediaType | undefined;
}

/** Automatically-generated message used to represent maps of ParameterOrReference as ordered (name,value) pairs. */
export interface NamedParameterOrReference {
  /** Map key */
  name: string;
  /** Mapped value */
  value: ParameterOrReference | undefined;
}

/** Automatically-generated message used to represent maps of PathItem as ordered (name,value) pairs. */
export interface NamedPathItem {
  /** Map key */
  name: string;
  /** Mapped value */
  value: PathItem | undefined;
}

/** Automatically-generated message used to represent maps of RequestBodyOrReference as ordered (name,value) pairs. */
export interface NamedRequestBodyOrReference {
  /** Map key */
  name: string;
  /** Mapped value */
  value: RequestBodyOrReference | undefined;
}

/** Automatically-generated message used to represent maps of ResponseOrReference as ordered (name,value) pairs. */
export interface NamedResponseOrReference {
  /** Map key */
  name: string;
  /** Mapped value */
  value: ResponseOrReference | undefined;
}

/** Automatically-generated message used to represent maps of SchemaOrReference as ordered (name,value) pairs. */
export interface NamedSchemaOrReference {
  /** Map key */
  name: string;
  /** Mapped value */
  value: SchemaOrReference | undefined;
}

/** Automatically-generated message used to represent maps of SecuritySchemeOrReference as ordered (name,value) pairs. */
export interface NamedSecuritySchemeOrReference {
  /** Map key */
  name: string;
  /** Mapped value */
  value: SecuritySchemeOrReference | undefined;
}

/** Automatically-generated message used to represent maps of ServerVariable as ordered (name,value) pairs. */
export interface NamedServerVariable {
  /** Map key */
  name: string;
  /** Mapped value */
  value: ServerVariable | undefined;
}

/** Automatically-generated message used to represent maps of string as ordered (name,value) pairs. */
export interface NamedString {
  /** Map key */
  name: string;
  /** Mapped value */
  value: string;
}

/** Automatically-generated message used to represent maps of StringArray as ordered (name,value) pairs. */
export interface NamedStringArray {
  /** Map key */
  name: string;
  /** Mapped value */
  value: StringArray | undefined;
}

/** Configuration details for a supported OAuth Flow */
export interface OauthFlow {
  authorizationUrl: string;
  tokenUrl: string;
  refreshUrl: string;
  scopes: Strings | undefined;
  specificationExtension: NamedAny[];
}

/** Allows configuration of the supported OAuth Flows. */
export interface OauthFlows {
  implicit: OauthFlow | undefined;
  password: OauthFlow | undefined;
  clientCredentials: OauthFlow | undefined;
  authorizationCode: OauthFlow | undefined;
  specificationExtension: NamedAny[];
}

export interface Object {
  additionalProperties: NamedAny[];
}

/** Describes a single API operation on a path. */
export interface Operation {
  tags: string[];
  summary: string;
  description: string;
  externalDocs: ExternalDocs | undefined;
  operationId: string;
  parameters: ParameterOrReference[];
  requestBody: RequestBodyOrReference | undefined;
  responses: Responses | undefined;
  callbacks: CallbacksOrReferences | undefined;
  deprecated: boolean;
  security: SecurityRequirement[];
  servers: Server[];
  specificationExtension: NamedAny[];
}

/** Describes a single operation parameter.  A unique parameter is defined by a combination of a name and location. */
export interface Parameter {
  name: string;
  in: string;
  description: string;
  required: boolean;
  deprecated: boolean;
  allowEmptyValue: boolean;
  style: string;
  explode: boolean;
  allowReserved: boolean;
  schema: SchemaOrReference | undefined;
  example: Any | undefined;
  examples: ExamplesOrReferences | undefined;
  content: MediaTypes | undefined;
  specificationExtension: NamedAny[];
}

export interface ParameterOrReference {
  parameter?: Parameter | undefined;
  reference?: Reference | undefined;
}

export interface ParametersOrReferences {
  additionalProperties: NamedParameterOrReference[];
}

/** Describes the operations available on a single path. A Path Item MAY be empty, due to ACL constraints. The path itself is still exposed to the documentation viewer but they will not know which operations and parameters are available. */
export interface PathItem {
  Ref: string;
  summary: string;
  description: string;
  get: Operation | undefined;
  put: Operation | undefined;
  post: Operation | undefined;
  delete: Operation | undefined;
  options: Operation | undefined;
  head: Operation | undefined;
  patch: Operation | undefined;
  trace: Operation | undefined;
  servers: Server[];
  parameters: ParameterOrReference[];
  specificationExtension: NamedAny[];
}

/** Holds the relative paths to the individual endpoints and their operations. The path is appended to the URL from the `Server Object` in order to construct the full URL.  The Paths MAY be empty, due to ACL constraints. */
export interface Paths {
  path: NamedPathItem[];
  specificationExtension: NamedAny[];
}

export interface Properties {
  additionalProperties: NamedSchemaOrReference[];
}

/** A simple object to allow referencing other components in the specification, internally and externally.  The Reference Object is defined by JSON Reference and follows the same structure, behavior and rules.   For this specification, reference resolution is accomplished as defined by the JSON Reference specification and not by the JSON Schema specification. */
export interface Reference {
  Ref: string;
  summary: string;
  description: string;
}

export interface RequestBodiesOrReferences {
  additionalProperties: NamedRequestBodyOrReference[];
}

/** Describes a single request body. */
export interface RequestBody {
  description: string;
  content: MediaTypes | undefined;
  required: boolean;
  specificationExtension: NamedAny[];
}

export interface RequestBodyOrReference {
  requestBody?: RequestBody | undefined;
  reference?: Reference | undefined;
}

/** Describes a single response from an API Operation, including design-time, static  `links` to operations based on the response. */
export interface Response {
  description: string;
  headers: HeadersOrReferences | undefined;
  content: MediaTypes | undefined;
  links: LinksOrReferences | undefined;
  specificationExtension: NamedAny[];
}

export interface ResponseOrReference {
  response?: Response | undefined;
  reference?: Reference | undefined;
}

/** A container for the expected responses of an operation. The container maps a HTTP response code to the expected response.  The documentation is not necessarily expected to cover all possible HTTP response codes because they may not be known in advance. However, documentation is expected to cover a successful operation response and any known errors.  The `default` MAY be used as a default response object for all HTTP codes  that are not covered individually by the specification.  The `Responses Object` MUST contain at least one response code, and it  SHOULD be the response for a successful operation call. */
export interface Responses {
  default: ResponseOrReference | undefined;
  responseOrReference: NamedResponseOrReference[];
  specificationExtension: NamedAny[];
}

export interface ResponsesOrReferences {
  additionalProperties: NamedResponseOrReference[];
}

/** The Schema Object allows the definition of input and output data types. These types can be objects, but also primitives and arrays. This object is an extended subset of the JSON Schema Specification Wright Draft 00.  For more information about the properties, see JSON Schema Core and JSON Schema Validation. Unless stated otherwise, the property definitions follow the JSON Schema. */
export interface Schema {
  nullable: boolean;
  discriminator: Discriminator | undefined;
  readOnly: boolean;
  writeOnly: boolean;
  xml: Xml | undefined;
  externalDocs: ExternalDocs | undefined;
  example: Any | undefined;
  deprecated: boolean;
  title: string;
  multipleOf: number;
  maximum: number;
  exclusiveMaximum: boolean;
  minimum: number;
  exclusiveMinimum: boolean;
  maxLength: number;
  minLength: number;
  pattern: string;
  maxItems: number;
  minItems: number;
  uniqueItems: boolean;
  maxProperties: number;
  minProperties: number;
  required: string[];
  enum: Any[];
  type: string;
  allOf: SchemaOrReference[];
  oneOf: SchemaOrReference[];
  anyOf: SchemaOrReference[];
  not: Schema | undefined;
  items: ItemsItem | undefined;
  properties: Properties | undefined;
  additionalProperties: AdditionalPropertiesItem | undefined;
  default: DefaultType | undefined;
  description: string;
  format: string;
  specificationExtension: NamedAny[];
}

export interface SchemaOrReference {
  schema?: Schema | undefined;
  reference?: Reference | undefined;
}

export interface SchemasOrReferences {
  additionalProperties: NamedSchemaOrReference[];
}

/** Lists the required security schemes to execute this operation. The name used for each property MUST correspond to a security scheme declared in the Security Schemes under the Components Object.  Security Requirement Objects that contain multiple schemes require that all schemes MUST be satisfied for a request to be authorized. This enables support for scenarios where multiple query parameters or HTTP headers are required to convey security information.  When a list of Security Requirement Objects is defined on the OpenAPI Object or Operation Object, only one of the Security Requirement Objects in the list needs to be satisfied to authorize the request. */
export interface SecurityRequirement {
  additionalProperties: NamedStringArray[];
}

/** Defines a security scheme that can be used by the operations. Supported schemes are HTTP authentication, an API key (either as a header, a cookie parameter or as a query parameter), mutual TLS (use of a client certificate), OAuth2's common flows (implicit, password, application and access code) as defined in RFC6749, and OpenID Connect.   Please note that currently (2019) the implicit flow is about to be deprecated OAuth 2.0 Security Best Current Practice. Recommended for most use case is Authorization Code Grant flow with PKCE. */
export interface SecurityScheme {
  type: string;
  description: string;
  name: string;
  in: string;
  scheme: string;
  bearerFormat: string;
  flows: OauthFlows | undefined;
  openIdConnectUrl: string;
  specificationExtension: NamedAny[];
}

export interface SecuritySchemeOrReference {
  securityScheme?: SecurityScheme | undefined;
  reference?: Reference | undefined;
}

export interface SecuritySchemesOrReferences {
  additionalProperties: NamedSecuritySchemeOrReference[];
}

/** An object representing a Server. */
export interface Server {
  url: string;
  description: string;
  variables: ServerVariables | undefined;
  specificationExtension: NamedAny[];
}

/** An object representing a Server Variable for server URL template substitution. */
export interface ServerVariable {
  enum: string[];
  default: string;
  description: string;
  specificationExtension: NamedAny[];
}

export interface ServerVariables {
  additionalProperties: NamedServerVariable[];
}

/** Any property starting with x- is valid. */
export interface SpecificationExtension {
  number?: number | undefined;
  boolean?: boolean | undefined;
  string?: string | undefined;
}

export interface StringArray {
  value: string[];
}

export interface Strings {
  additionalProperties: NamedString[];
}

/** Adds metadata to a single tag that is used by the Operation Object. It is not mandatory to have a Tag Object per tag defined in the Operation Object instances. */
export interface Tag {
  name: string;
  description: string;
  externalDocs: ExternalDocs | undefined;
  specificationExtension: NamedAny[];
}

/** A metadata object that allows for more fine-tuned XML model definitions.  When using arrays, XML element names are *not* inferred (for singular/plural forms) and the `name` property SHOULD be used to add that information. See examples for expected behavior. */
export interface Xml {
  name: string;
  namespace: string;
  prefix: string;
  attribute: boolean;
  wrapped: boolean;
  specificationExtension: NamedAny[];
}

function createBaseAdditionalPropertiesItem(): AdditionalPropertiesItem {
  return { schemaOrReference: undefined, boolean: undefined };
}

export const AdditionalPropertiesItem: MessageFns<AdditionalPropertiesItem> = {
  encode(
    message: AdditionalPropertiesItem,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.schemaOrReference !== undefined) {
      SchemaOrReference.encode(
        message.schemaOrReference,
        writer.uint32(10).fork()
      ).join();
    }
    if (message.boolean !== undefined) {
      writer.uint32(16).bool(message.boolean);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): AdditionalPropertiesItem {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdditionalPropertiesItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaOrReference = SchemaOrReference.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.boolean = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdditionalPropertiesItem {
    return {
      schemaOrReference: isSet(object.schemaOrReference)
        ? SchemaOrReference.fromJSON(object.schemaOrReference)
        : undefined,
      boolean: isSet(object.boolean)
        ? globalThis.Boolean(object.boolean)
        : undefined
    };
  },

  toJSON(message: AdditionalPropertiesItem): unknown {
    const obj: any = {};
    if (message.schemaOrReference !== undefined) {
      obj.schemaOrReference = SchemaOrReference.toJSON(
        message.schemaOrReference
      );
    }
    if (message.boolean !== undefined) {
      obj.boolean = message.boolean;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdditionalPropertiesItem>, I>>(
    base?: I
  ): AdditionalPropertiesItem {
    return AdditionalPropertiesItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdditionalPropertiesItem>, I>>(
    object: I
  ): AdditionalPropertiesItem {
    const message = createBaseAdditionalPropertiesItem();
    message.schemaOrReference =
      object.schemaOrReference !== undefined &&
      object.schemaOrReference !== null
        ? SchemaOrReference.fromPartial(object.schemaOrReference)
        : undefined;
    message.boolean = object.boolean ?? undefined;
    return message;
  }
};

function createBaseAny(): Any {
  return { value: undefined, yaml: "" };
}

export const Any: MessageFns<Any> = {
  encode(
    message: Any,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.value !== undefined) {
      Any1.encode(message.value, writer.uint32(10).fork()).join();
    }
    if (message.yaml !== "") {
      writer.uint32(18).string(message.yaml);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Any {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAny();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = Any1.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.yaml = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Any {
    return {
      value: isSet(object.value) ? Any1.fromJSON(object.value) : undefined,
      yaml: isSet(object.yaml) ? globalThis.String(object.yaml) : ""
    };
  },

  toJSON(message: Any): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = Any1.toJSON(message.value);
    }
    if (message.yaml !== "") {
      obj.yaml = message.yaml;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Any>, I>>(base?: I): Any {
    return Any.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Any>, I>>(object: I): Any {
    const message = createBaseAny();
    message.value =
      object.value !== undefined && object.value !== null
        ? Any1.fromPartial(object.value)
        : undefined;
    message.yaml = object.yaml ?? "";
    return message;
  }
};

function createBaseAnyOrExpression(): AnyOrExpression {
  return { any: undefined, expression: undefined };
}

export const AnyOrExpression: MessageFns<AnyOrExpression> = {
  encode(
    message: AnyOrExpression,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.any !== undefined) {
      Any.encode(message.any, writer.uint32(10).fork()).join();
    }
    if (message.expression !== undefined) {
      Expression.encode(message.expression, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnyOrExpression {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnyOrExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.any = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expression = Expression.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnyOrExpression {
    return {
      any: isSet(object.any) ? Any.fromJSON(object.any) : undefined,
      expression: isSet(object.expression)
        ? Expression.fromJSON(object.expression)
        : undefined
    };
  },

  toJSON(message: AnyOrExpression): unknown {
    const obj: any = {};
    if (message.any !== undefined) {
      obj.any = Any.toJSON(message.any);
    }
    if (message.expression !== undefined) {
      obj.expression = Expression.toJSON(message.expression);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnyOrExpression>, I>>(
    base?: I
  ): AnyOrExpression {
    return AnyOrExpression.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnyOrExpression>, I>>(
    object: I
  ): AnyOrExpression {
    const message = createBaseAnyOrExpression();
    message.any =
      object.any !== undefined && object.any !== null
        ? Any.fromPartial(object.any)
        : undefined;
    message.expression =
      object.expression !== undefined && object.expression !== null
        ? Expression.fromPartial(object.expression)
        : undefined;
    return message;
  }
};

function createBaseCallback(): Callback {
  return { path: [], specificationExtension: [] };
}

export const Callback: MessageFns<Callback> = {
  encode(
    message: Callback,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.path) {
      NamedPathItem.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Callback {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path.push(NamedPathItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Callback {
    return {
      path: globalThis.Array.isArray(object?.path)
        ? object.path.map((e: any) => NamedPathItem.fromJSON(e))
        : [],
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Callback): unknown {
    const obj: any = {};
    if (message.path?.length) {
      obj.path = message.path.map(e => NamedPathItem.toJSON(e));
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Callback>, I>>(base?: I): Callback {
    return Callback.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Callback>, I>>(object: I): Callback {
    const message = createBaseCallback();
    message.path = object.path?.map(e => NamedPathItem.fromPartial(e)) || [];
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseCallbackOrReference(): CallbackOrReference {
  return { callback: undefined, reference: undefined };
}

export const CallbackOrReference: MessageFns<CallbackOrReference> = {
  encode(
    message: CallbackOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.callback !== undefined) {
      Callback.encode(message.callback, writer.uint32(10).fork()).join();
    }
    if (message.reference !== undefined) {
      Reference.encode(message.reference, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): CallbackOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallbackOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.callback = Callback.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = Reference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallbackOrReference {
    return {
      callback: isSet(object.callback)
        ? Callback.fromJSON(object.callback)
        : undefined,
      reference: isSet(object.reference)
        ? Reference.fromJSON(object.reference)
        : undefined
    };
  },

  toJSON(message: CallbackOrReference): unknown {
    const obj: any = {};
    if (message.callback !== undefined) {
      obj.callback = Callback.toJSON(message.callback);
    }
    if (message.reference !== undefined) {
      obj.reference = Reference.toJSON(message.reference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallbackOrReference>, I>>(
    base?: I
  ): CallbackOrReference {
    return CallbackOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallbackOrReference>, I>>(
    object: I
  ): CallbackOrReference {
    const message = createBaseCallbackOrReference();
    message.callback =
      object.callback !== undefined && object.callback !== null
        ? Callback.fromPartial(object.callback)
        : undefined;
    message.reference =
      object.reference !== undefined && object.reference !== null
        ? Reference.fromPartial(object.reference)
        : undefined;
    return message;
  }
};

function createBaseCallbacksOrReferences(): CallbacksOrReferences {
  return { additionalProperties: [] };
}

export const CallbacksOrReferences: MessageFns<CallbacksOrReferences> = {
  encode(
    message: CallbacksOrReferences,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedCallbackOrReference.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): CallbacksOrReferences {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallbacksOrReferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedCallbackOrReference.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallbacksOrReferences {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) =>
            NamedCallbackOrReference.fromJSON(e)
          )
        : []
    };
  },

  toJSON(message: CallbacksOrReferences): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedCallbackOrReference.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallbacksOrReferences>, I>>(
    base?: I
  ): CallbacksOrReferences {
    return CallbacksOrReferences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallbacksOrReferences>, I>>(
    object: I
  ): CallbacksOrReferences {
    const message = createBaseCallbacksOrReferences();
    message.additionalProperties =
      object.additionalProperties?.map(e =>
        NamedCallbackOrReference.fromPartial(e)
      ) || [];
    return message;
  }
};

function createBaseComponents(): Components {
  return {
    schemas: undefined,
    responses: undefined,
    parameters: undefined,
    examples: undefined,
    requestBodies: undefined,
    headers: undefined,
    securitySchemes: undefined,
    links: undefined,
    callbacks: undefined,
    specificationExtension: []
  };
}

export const Components: MessageFns<Components> = {
  encode(
    message: Components,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.schemas !== undefined) {
      SchemasOrReferences.encode(
        message.schemas,
        writer.uint32(10).fork()
      ).join();
    }
    if (message.responses !== undefined) {
      ResponsesOrReferences.encode(
        message.responses,
        writer.uint32(18).fork()
      ).join();
    }
    if (message.parameters !== undefined) {
      ParametersOrReferences.encode(
        message.parameters,
        writer.uint32(26).fork()
      ).join();
    }
    if (message.examples !== undefined) {
      ExamplesOrReferences.encode(
        message.examples,
        writer.uint32(34).fork()
      ).join();
    }
    if (message.requestBodies !== undefined) {
      RequestBodiesOrReferences.encode(
        message.requestBodies,
        writer.uint32(42).fork()
      ).join();
    }
    if (message.headers !== undefined) {
      HeadersOrReferences.encode(
        message.headers,
        writer.uint32(50).fork()
      ).join();
    }
    if (message.securitySchemes !== undefined) {
      SecuritySchemesOrReferences.encode(
        message.securitySchemes,
        writer.uint32(58).fork()
      ).join();
    }
    if (message.links !== undefined) {
      LinksOrReferences.encode(message.links, writer.uint32(66).fork()).join();
    }
    if (message.callbacks !== undefined) {
      CallbacksOrReferences.encode(
        message.callbacks,
        writer.uint32(74).fork()
      ).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Components {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemas = SchemasOrReferences.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.responses = ResponsesOrReferences.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parameters = ParametersOrReferences.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.examples = ExamplesOrReferences.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requestBodies = RequestBodiesOrReferences.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.headers = HeadersOrReferences.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.securitySchemes = SecuritySchemesOrReferences.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.links = LinksOrReferences.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.callbacks = CallbacksOrReferences.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Components {
    return {
      schemas: isSet(object.schemas)
        ? SchemasOrReferences.fromJSON(object.schemas)
        : undefined,
      responses: isSet(object.responses)
        ? ResponsesOrReferences.fromJSON(object.responses)
        : undefined,
      parameters: isSet(object.parameters)
        ? ParametersOrReferences.fromJSON(object.parameters)
        : undefined,
      examples: isSet(object.examples)
        ? ExamplesOrReferences.fromJSON(object.examples)
        : undefined,
      requestBodies: isSet(object.requestBodies)
        ? RequestBodiesOrReferences.fromJSON(object.requestBodies)
        : undefined,
      headers: isSet(object.headers)
        ? HeadersOrReferences.fromJSON(object.headers)
        : undefined,
      securitySchemes: isSet(object.securitySchemes)
        ? SecuritySchemesOrReferences.fromJSON(object.securitySchemes)
        : undefined,
      links: isSet(object.links)
        ? LinksOrReferences.fromJSON(object.links)
        : undefined,
      callbacks: isSet(object.callbacks)
        ? CallbacksOrReferences.fromJSON(object.callbacks)
        : undefined,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Components): unknown {
    const obj: any = {};
    if (message.schemas !== undefined) {
      obj.schemas = SchemasOrReferences.toJSON(message.schemas);
    }
    if (message.responses !== undefined) {
      obj.responses = ResponsesOrReferences.toJSON(message.responses);
    }
    if (message.parameters !== undefined) {
      obj.parameters = ParametersOrReferences.toJSON(message.parameters);
    }
    if (message.examples !== undefined) {
      obj.examples = ExamplesOrReferences.toJSON(message.examples);
    }
    if (message.requestBodies !== undefined) {
      obj.requestBodies = RequestBodiesOrReferences.toJSON(
        message.requestBodies
      );
    }
    if (message.headers !== undefined) {
      obj.headers = HeadersOrReferences.toJSON(message.headers);
    }
    if (message.securitySchemes !== undefined) {
      obj.securitySchemes = SecuritySchemesOrReferences.toJSON(
        message.securitySchemes
      );
    }
    if (message.links !== undefined) {
      obj.links = LinksOrReferences.toJSON(message.links);
    }
    if (message.callbacks !== undefined) {
      obj.callbacks = CallbacksOrReferences.toJSON(message.callbacks);
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Components>, I>>(base?: I): Components {
    return Components.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Components>, I>>(
    object: I
  ): Components {
    const message = createBaseComponents();
    message.schemas =
      object.schemas !== undefined && object.schemas !== null
        ? SchemasOrReferences.fromPartial(object.schemas)
        : undefined;
    message.responses =
      object.responses !== undefined && object.responses !== null
        ? ResponsesOrReferences.fromPartial(object.responses)
        : undefined;
    message.parameters =
      object.parameters !== undefined && object.parameters !== null
        ? ParametersOrReferences.fromPartial(object.parameters)
        : undefined;
    message.examples =
      object.examples !== undefined && object.examples !== null
        ? ExamplesOrReferences.fromPartial(object.examples)
        : undefined;
    message.requestBodies =
      object.requestBodies !== undefined && object.requestBodies !== null
        ? RequestBodiesOrReferences.fromPartial(object.requestBodies)
        : undefined;
    message.headers =
      object.headers !== undefined && object.headers !== null
        ? HeadersOrReferences.fromPartial(object.headers)
        : undefined;
    message.securitySchemes =
      object.securitySchemes !== undefined && object.securitySchemes !== null
        ? SecuritySchemesOrReferences.fromPartial(object.securitySchemes)
        : undefined;
    message.links =
      object.links !== undefined && object.links !== null
        ? LinksOrReferences.fromPartial(object.links)
        : undefined;
    message.callbacks =
      object.callbacks !== undefined && object.callbacks !== null
        ? CallbacksOrReferences.fromPartial(object.callbacks)
        : undefined;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseContact(): Contact {
  return { name: "", url: "", email: "", specificationExtension: [] };
}

export const Contact: MessageFns<Contact> = {
  encode(
    message: Contact,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Contact {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Contact {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Contact): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Contact>, I>>(base?: I): Contact {
    return Contact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Contact>, I>>(object: I): Contact {
    const message = createBaseContact();
    message.name = object.name ?? "";
    message.url = object.url ?? "";
    message.email = object.email ?? "";
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseDefaultType(): DefaultType {
  return { number: undefined, boolean: undefined, string: undefined };
}

export const DefaultType: MessageFns<DefaultType> = {
  encode(
    message: DefaultType,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.number !== undefined) {
      writer.uint32(9).double(message.number);
    }
    if (message.boolean !== undefined) {
      writer.uint32(16).bool(message.boolean);
    }
    if (message.string !== undefined) {
      writer.uint32(26).string(message.string);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DefaultType {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.number = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.boolean = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.string = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultType {
    return {
      number: isSet(object.number)
        ? globalThis.Number(object.number)
        : undefined,
      boolean: isSet(object.boolean)
        ? globalThis.Boolean(object.boolean)
        : undefined,
      string: isSet(object.string)
        ? globalThis.String(object.string)
        : undefined
    };
  },

  toJSON(message: DefaultType): unknown {
    const obj: any = {};
    if (message.number !== undefined) {
      obj.number = message.number;
    }
    if (message.boolean !== undefined) {
      obj.boolean = message.boolean;
    }
    if (message.string !== undefined) {
      obj.string = message.string;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DefaultType>, I>>(base?: I): DefaultType {
    return DefaultType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DefaultType>, I>>(
    object: I
  ): DefaultType {
    const message = createBaseDefaultType();
    message.number = object.number ?? undefined;
    message.boolean = object.boolean ?? undefined;
    message.string = object.string ?? undefined;
    return message;
  }
};

function createBaseDiscriminator(): Discriminator {
  return { propertyName: "", mapping: undefined, specificationExtension: [] };
}

export const Discriminator: MessageFns<Discriminator> = {
  encode(
    message: Discriminator,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.propertyName !== "") {
      writer.uint32(10).string(message.propertyName);
    }
    if (message.mapping !== undefined) {
      Strings.encode(message.mapping, writer.uint32(18).fork()).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Discriminator {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscriminator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.propertyName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mapping = Strings.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Discriminator {
    return {
      propertyName: isSet(object.propertyName)
        ? globalThis.String(object.propertyName)
        : "",
      mapping: isSet(object.mapping)
        ? Strings.fromJSON(object.mapping)
        : undefined,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Discriminator): unknown {
    const obj: any = {};
    if (message.propertyName !== "") {
      obj.propertyName = message.propertyName;
    }
    if (message.mapping !== undefined) {
      obj.mapping = Strings.toJSON(message.mapping);
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Discriminator>, I>>(
    base?: I
  ): Discriminator {
    return Discriminator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Discriminator>, I>>(
    object: I
  ): Discriminator {
    const message = createBaseDiscriminator();
    message.propertyName = object.propertyName ?? "";
    message.mapping =
      object.mapping !== undefined && object.mapping !== null
        ? Strings.fromPartial(object.mapping)
        : undefined;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseDocument(): Document {
  return {
    openapi: "",
    info: undefined,
    servers: [],
    paths: undefined,
    components: undefined,
    security: [],
    tags: [],
    externalDocs: undefined,
    specificationExtension: []
  };
}

export const Document: MessageFns<Document> = {
  encode(
    message: Document,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.openapi !== "") {
      writer.uint32(10).string(message.openapi);
    }
    if (message.info !== undefined) {
      Info.encode(message.info, writer.uint32(18).fork()).join();
    }
    for (const v of message.servers) {
      Server.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.paths !== undefined) {
      Paths.encode(message.paths, writer.uint32(34).fork()).join();
    }
    if (message.components !== undefined) {
      Components.encode(message.components, writer.uint32(42).fork()).join();
    }
    for (const v of message.security) {
      SecurityRequirement.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.tags) {
      Tag.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.externalDocs !== undefined) {
      ExternalDocs.encode(
        message.externalDocs,
        writer.uint32(66).fork()
      ).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.openapi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.info = Info.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.servers.push(Server.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paths = Paths.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.components = Components.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.security.push(
            SecurityRequirement.decode(reader, reader.uint32())
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tags.push(Tag.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.externalDocs = ExternalDocs.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document {
    return {
      openapi: isSet(object.openapi) ? globalThis.String(object.openapi) : "",
      info: isSet(object.info) ? Info.fromJSON(object.info) : undefined,
      servers: globalThis.Array.isArray(object?.servers)
        ? object.servers.map((e: any) => Server.fromJSON(e))
        : [],
      paths: isSet(object.paths) ? Paths.fromJSON(object.paths) : undefined,
      components: isSet(object.components)
        ? Components.fromJSON(object.components)
        : undefined,
      security: globalThis.Array.isArray(object?.security)
        ? object.security.map((e: any) => SecurityRequirement.fromJSON(e))
        : [],
      tags: globalThis.Array.isArray(object?.tags)
        ? object.tags.map((e: any) => Tag.fromJSON(e))
        : [],
      externalDocs: isSet(object.externalDocs)
        ? ExternalDocs.fromJSON(object.externalDocs)
        : undefined,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Document): unknown {
    const obj: any = {};
    if (message.openapi !== "") {
      obj.openapi = message.openapi;
    }
    if (message.info !== undefined) {
      obj.info = Info.toJSON(message.info);
    }
    if (message.servers?.length) {
      obj.servers = message.servers.map(e => Server.toJSON(e));
    }
    if (message.paths !== undefined) {
      obj.paths = Paths.toJSON(message.paths);
    }
    if (message.components !== undefined) {
      obj.components = Components.toJSON(message.components);
    }
    if (message.security?.length) {
      obj.security = message.security.map(e => SecurityRequirement.toJSON(e));
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map(e => Tag.toJSON(e));
    }
    if (message.externalDocs !== undefined) {
      obj.externalDocs = ExternalDocs.toJSON(message.externalDocs);
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Document>, I>>(base?: I): Document {
    return Document.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Document>, I>>(object: I): Document {
    const message = createBaseDocument();
    message.openapi = object.openapi ?? "";
    message.info =
      object.info !== undefined && object.info !== null
        ? Info.fromPartial(object.info)
        : undefined;
    message.servers = object.servers?.map(e => Server.fromPartial(e)) || [];
    message.paths =
      object.paths !== undefined && object.paths !== null
        ? Paths.fromPartial(object.paths)
        : undefined;
    message.components =
      object.components !== undefined && object.components !== null
        ? Components.fromPartial(object.components)
        : undefined;
    message.security =
      object.security?.map(e => SecurityRequirement.fromPartial(e)) || [];
    message.tags = object.tags?.map(e => Tag.fromPartial(e)) || [];
    message.externalDocs =
      object.externalDocs !== undefined && object.externalDocs !== null
        ? ExternalDocs.fromPartial(object.externalDocs)
        : undefined;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseEncoding(): Encoding {
  return {
    contentType: "",
    headers: undefined,
    style: "",
    explode: false,
    allowReserved: false,
    specificationExtension: []
  };
}

export const Encoding: MessageFns<Encoding> = {
  encode(
    message: Encoding,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.contentType !== "") {
      writer.uint32(10).string(message.contentType);
    }
    if (message.headers !== undefined) {
      HeadersOrReferences.encode(
        message.headers,
        writer.uint32(18).fork()
      ).join();
    }
    if (message.style !== "") {
      writer.uint32(26).string(message.style);
    }
    if (message.explode !== false) {
      writer.uint32(32).bool(message.explode);
    }
    if (message.allowReserved !== false) {
      writer.uint32(40).bool(message.allowReserved);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encoding {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncoding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.headers = HeadersOrReferences.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.style = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.explode = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.allowReserved = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Encoding {
    return {
      contentType: isSet(object.contentType)
        ? globalThis.String(object.contentType)
        : "",
      headers: isSet(object.headers)
        ? HeadersOrReferences.fromJSON(object.headers)
        : undefined,
      style: isSet(object.style) ? globalThis.String(object.style) : "",
      explode: isSet(object.explode)
        ? globalThis.Boolean(object.explode)
        : false,
      allowReserved: isSet(object.allowReserved)
        ? globalThis.Boolean(object.allowReserved)
        : false,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Encoding): unknown {
    const obj: any = {};
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.headers !== undefined) {
      obj.headers = HeadersOrReferences.toJSON(message.headers);
    }
    if (message.style !== "") {
      obj.style = message.style;
    }
    if (message.explode !== false) {
      obj.explode = message.explode;
    }
    if (message.allowReserved !== false) {
      obj.allowReserved = message.allowReserved;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Encoding>, I>>(base?: I): Encoding {
    return Encoding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Encoding>, I>>(object: I): Encoding {
    const message = createBaseEncoding();
    message.contentType = object.contentType ?? "";
    message.headers =
      object.headers !== undefined && object.headers !== null
        ? HeadersOrReferences.fromPartial(object.headers)
        : undefined;
    message.style = object.style ?? "";
    message.explode = object.explode ?? false;
    message.allowReserved = object.allowReserved ?? false;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseEncodings(): Encodings {
  return { additionalProperties: [] };
}

export const Encodings: MessageFns<Encodings> = {
  encode(
    message: Encodings,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedEncoding.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encodings {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncodings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedEncoding.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Encodings {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) => NamedEncoding.fromJSON(e))
        : []
    };
  },

  toJSON(message: Encodings): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedEncoding.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Encodings>, I>>(base?: I): Encodings {
    return Encodings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Encodings>, I>>(
    object: I
  ): Encodings {
    const message = createBaseEncodings();
    message.additionalProperties =
      object.additionalProperties?.map(e => NamedEncoding.fromPartial(e)) || [];
    return message;
  }
};

function createBaseExample(): Example {
  return {
    summary: "",
    description: "",
    value: undefined,
    externalValue: "",
    specificationExtension: []
  };
}

export const Example: MessageFns<Example> = {
  encode(
    message: Example,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.summary !== "") {
      writer.uint32(10).string(message.summary);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(26).fork()).join();
    }
    if (message.externalValue !== "") {
      writer.uint32(34).string(message.externalValue);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Example {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.externalValue = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Example {
    return {
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
      externalValue: isSet(object.externalValue)
        ? globalThis.String(object.externalValue)
        : "",
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Example): unknown {
    const obj: any = {};
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    if (message.externalValue !== "") {
      obj.externalValue = message.externalValue;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Example>, I>>(base?: I): Example {
    return Example.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Example>, I>>(object: I): Example {
    const message = createBaseExample();
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? Any.fromPartial(object.value)
        : undefined;
    message.externalValue = object.externalValue ?? "";
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseExampleOrReference(): ExampleOrReference {
  return { example: undefined, reference: undefined };
}

export const ExampleOrReference: MessageFns<ExampleOrReference> = {
  encode(
    message: ExampleOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.example !== undefined) {
      Example.encode(message.example, writer.uint32(10).fork()).join();
    }
    if (message.reference !== undefined) {
      Reference.encode(message.reference, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): ExampleOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExampleOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.example = Example.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = Reference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExampleOrReference {
    return {
      example: isSet(object.example)
        ? Example.fromJSON(object.example)
        : undefined,
      reference: isSet(object.reference)
        ? Reference.fromJSON(object.reference)
        : undefined
    };
  },

  toJSON(message: ExampleOrReference): unknown {
    const obj: any = {};
    if (message.example !== undefined) {
      obj.example = Example.toJSON(message.example);
    }
    if (message.reference !== undefined) {
      obj.reference = Reference.toJSON(message.reference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExampleOrReference>, I>>(
    base?: I
  ): ExampleOrReference {
    return ExampleOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExampleOrReference>, I>>(
    object: I
  ): ExampleOrReference {
    const message = createBaseExampleOrReference();
    message.example =
      object.example !== undefined && object.example !== null
        ? Example.fromPartial(object.example)
        : undefined;
    message.reference =
      object.reference !== undefined && object.reference !== null
        ? Reference.fromPartial(object.reference)
        : undefined;
    return message;
  }
};

function createBaseExamplesOrReferences(): ExamplesOrReferences {
  return { additionalProperties: [] };
}

export const ExamplesOrReferences: MessageFns<ExamplesOrReferences> = {
  encode(
    message: ExamplesOrReferences,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedExampleOrReference.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): ExamplesOrReferences {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExamplesOrReferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedExampleOrReference.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExamplesOrReferences {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) =>
            NamedExampleOrReference.fromJSON(e)
          )
        : []
    };
  },

  toJSON(message: ExamplesOrReferences): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedExampleOrReference.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExamplesOrReferences>, I>>(
    base?: I
  ): ExamplesOrReferences {
    return ExamplesOrReferences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExamplesOrReferences>, I>>(
    object: I
  ): ExamplesOrReferences {
    const message = createBaseExamplesOrReferences();
    message.additionalProperties =
      object.additionalProperties?.map(e =>
        NamedExampleOrReference.fromPartial(e)
      ) || [];
    return message;
  }
};

function createBaseExpression(): Expression {
  return { additionalProperties: [] };
}

export const Expression: MessageFns<Expression> = {
  encode(
    message: Expression,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedAny.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expression {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Expression {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Expression): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Expression>, I>>(base?: I): Expression {
    return Expression.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Expression>, I>>(
    object: I
  ): Expression {
    const message = createBaseExpression();
    message.additionalProperties =
      object.additionalProperties?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseExternalDocs(): ExternalDocs {
  return { description: "", url: "", specificationExtension: [] };
}

export const ExternalDocs: MessageFns<ExternalDocs> = {
  encode(
    message: ExternalDocs,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalDocs {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalDocs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalDocs {
    return {
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: ExternalDocs): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExternalDocs>, I>>(
    base?: I
  ): ExternalDocs {
    return ExternalDocs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExternalDocs>, I>>(
    object: I
  ): ExternalDocs {
    const message = createBaseExternalDocs();
    message.description = object.description ?? "";
    message.url = object.url ?? "";
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseHeader(): Header {
  return {
    description: "",
    required: false,
    deprecated: false,
    allowEmptyValue: false,
    style: "",
    explode: false,
    allowReserved: false,
    schema: undefined,
    example: undefined,
    examples: undefined,
    content: undefined,
    specificationExtension: []
  };
}

export const Header: MessageFns<Header> = {
  encode(
    message: Header,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.required !== false) {
      writer.uint32(16).bool(message.required);
    }
    if (message.deprecated !== false) {
      writer.uint32(24).bool(message.deprecated);
    }
    if (message.allowEmptyValue !== false) {
      writer.uint32(32).bool(message.allowEmptyValue);
    }
    if (message.style !== "") {
      writer.uint32(42).string(message.style);
    }
    if (message.explode !== false) {
      writer.uint32(48).bool(message.explode);
    }
    if (message.allowReserved !== false) {
      writer.uint32(56).bool(message.allowReserved);
    }
    if (message.schema !== undefined) {
      SchemaOrReference.encode(message.schema, writer.uint32(66).fork()).join();
    }
    if (message.example !== undefined) {
      Any.encode(message.example, writer.uint32(74).fork()).join();
    }
    if (message.examples !== undefined) {
      ExamplesOrReferences.encode(
        message.examples,
        writer.uint32(82).fork()
      ).join();
    }
    if (message.content !== undefined) {
      MediaTypes.encode(message.content, writer.uint32(90).fork()).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Header {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.deprecated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.allowEmptyValue = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.style = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.explode = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.allowReserved = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.schema = SchemaOrReference.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.example = Any.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.examples = ExamplesOrReferences.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.content = MediaTypes.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Header {
    return {
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      required: isSet(object.required)
        ? globalThis.Boolean(object.required)
        : false,
      deprecated: isSet(object.deprecated)
        ? globalThis.Boolean(object.deprecated)
        : false,
      allowEmptyValue: isSet(object.allowEmptyValue)
        ? globalThis.Boolean(object.allowEmptyValue)
        : false,
      style: isSet(object.style) ? globalThis.String(object.style) : "",
      explode: isSet(object.explode)
        ? globalThis.Boolean(object.explode)
        : false,
      allowReserved: isSet(object.allowReserved)
        ? globalThis.Boolean(object.allowReserved)
        : false,
      schema: isSet(object.schema)
        ? SchemaOrReference.fromJSON(object.schema)
        : undefined,
      example: isSet(object.example) ? Any.fromJSON(object.example) : undefined,
      examples: isSet(object.examples)
        ? ExamplesOrReferences.fromJSON(object.examples)
        : undefined,
      content: isSet(object.content)
        ? MediaTypes.fromJSON(object.content)
        : undefined,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Header): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.allowEmptyValue !== false) {
      obj.allowEmptyValue = message.allowEmptyValue;
    }
    if (message.style !== "") {
      obj.style = message.style;
    }
    if (message.explode !== false) {
      obj.explode = message.explode;
    }
    if (message.allowReserved !== false) {
      obj.allowReserved = message.allowReserved;
    }
    if (message.schema !== undefined) {
      obj.schema = SchemaOrReference.toJSON(message.schema);
    }
    if (message.example !== undefined) {
      obj.example = Any.toJSON(message.example);
    }
    if (message.examples !== undefined) {
      obj.examples = ExamplesOrReferences.toJSON(message.examples);
    }
    if (message.content !== undefined) {
      obj.content = MediaTypes.toJSON(message.content);
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Header>, I>>(base?: I): Header {
    return Header.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Header>, I>>(object: I): Header {
    const message = createBaseHeader();
    message.description = object.description ?? "";
    message.required = object.required ?? false;
    message.deprecated = object.deprecated ?? false;
    message.allowEmptyValue = object.allowEmptyValue ?? false;
    message.style = object.style ?? "";
    message.explode = object.explode ?? false;
    message.allowReserved = object.allowReserved ?? false;
    message.schema =
      object.schema !== undefined && object.schema !== null
        ? SchemaOrReference.fromPartial(object.schema)
        : undefined;
    message.example =
      object.example !== undefined && object.example !== null
        ? Any.fromPartial(object.example)
        : undefined;
    message.examples =
      object.examples !== undefined && object.examples !== null
        ? ExamplesOrReferences.fromPartial(object.examples)
        : undefined;
    message.content =
      object.content !== undefined && object.content !== null
        ? MediaTypes.fromPartial(object.content)
        : undefined;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseHeaderOrReference(): HeaderOrReference {
  return { header: undefined, reference: undefined };
}

export const HeaderOrReference: MessageFns<HeaderOrReference> = {
  encode(
    message: HeaderOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.header !== undefined) {
      Header.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.reference !== undefined) {
      Reference.encode(message.reference, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = Header.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = Reference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderOrReference {
    return {
      header: isSet(object.header) ? Header.fromJSON(object.header) : undefined,
      reference: isSet(object.reference)
        ? Reference.fromJSON(object.reference)
        : undefined
    };
  },

  toJSON(message: HeaderOrReference): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = Header.toJSON(message.header);
    }
    if (message.reference !== undefined) {
      obj.reference = Reference.toJSON(message.reference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderOrReference>, I>>(
    base?: I
  ): HeaderOrReference {
    return HeaderOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderOrReference>, I>>(
    object: I
  ): HeaderOrReference {
    const message = createBaseHeaderOrReference();
    message.header =
      object.header !== undefined && object.header !== null
        ? Header.fromPartial(object.header)
        : undefined;
    message.reference =
      object.reference !== undefined && object.reference !== null
        ? Reference.fromPartial(object.reference)
        : undefined;
    return message;
  }
};

function createBaseHeadersOrReferences(): HeadersOrReferences {
  return { additionalProperties: [] };
}

export const HeadersOrReferences: MessageFns<HeadersOrReferences> = {
  encode(
    message: HeadersOrReferences,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedHeaderOrReference.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): HeadersOrReferences {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeadersOrReferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedHeaderOrReference.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeadersOrReferences {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) =>
            NamedHeaderOrReference.fromJSON(e)
          )
        : []
    };
  },

  toJSON(message: HeadersOrReferences): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedHeaderOrReference.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeadersOrReferences>, I>>(
    base?: I
  ): HeadersOrReferences {
    return HeadersOrReferences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeadersOrReferences>, I>>(
    object: I
  ): HeadersOrReferences {
    const message = createBaseHeadersOrReferences();
    message.additionalProperties =
      object.additionalProperties?.map(e =>
        NamedHeaderOrReference.fromPartial(e)
      ) || [];
    return message;
  }
};

function createBaseInfo(): Info {
  return {
    title: "",
    description: "",
    termsOfService: "",
    contact: undefined,
    license: undefined,
    version: "",
    specificationExtension: [],
    summary: ""
  };
}

export const Info: MessageFns<Info> = {
  encode(
    message: Info,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.termsOfService !== "") {
      writer.uint32(26).string(message.termsOfService);
    }
    if (message.contact !== undefined) {
      Contact.encode(message.contact, writer.uint32(34).fork()).join();
    }
    if (message.license !== undefined) {
      License.encode(message.license, writer.uint32(42).fork()).join();
    }
    if (message.version !== "") {
      writer.uint32(50).string(message.version);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.summary !== "") {
      writer.uint32(66).string(message.summary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Info {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.termsOfService = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contact = Contact.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.license = License.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Info {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      termsOfService: isSet(object.termsOfService)
        ? globalThis.String(object.termsOfService)
        : "",
      contact: isSet(object.contact)
        ? Contact.fromJSON(object.contact)
        : undefined,
      license: isSet(object.license)
        ? License.fromJSON(object.license)
        : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : [],
      summary: isSet(object.summary) ? globalThis.String(object.summary) : ""
    };
  },

  toJSON(message: Info): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.termsOfService !== "") {
      obj.termsOfService = message.termsOfService;
    }
    if (message.contact !== undefined) {
      obj.contact = Contact.toJSON(message.contact);
    }
    if (message.license !== undefined) {
      obj.license = License.toJSON(message.license);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Info>, I>>(base?: I): Info {
    return Info.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Info>, I>>(object: I): Info {
    const message = createBaseInfo();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.termsOfService = object.termsOfService ?? "";
    message.contact =
      object.contact !== undefined && object.contact !== null
        ? Contact.fromPartial(object.contact)
        : undefined;
    message.license =
      object.license !== undefined && object.license !== null
        ? License.fromPartial(object.license)
        : undefined;
    message.version = object.version ?? "";
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    message.summary = object.summary ?? "";
    return message;
  }
};

function createBaseItemsItem(): ItemsItem {
  return { schemaOrReference: [] };
}

export const ItemsItem: MessageFns<ItemsItem> = {
  encode(
    message: ItemsItem,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.schemaOrReference) {
      SchemaOrReference.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemsItem {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemsItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaOrReference.push(
            SchemaOrReference.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemsItem {
    return {
      schemaOrReference: globalThis.Array.isArray(object?.schemaOrReference)
        ? object.schemaOrReference.map((e: any) =>
            SchemaOrReference.fromJSON(e)
          )
        : []
    };
  },

  toJSON(message: ItemsItem): unknown {
    const obj: any = {};
    if (message.schemaOrReference?.length) {
      obj.schemaOrReference = message.schemaOrReference.map(e =>
        SchemaOrReference.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemsItem>, I>>(base?: I): ItemsItem {
    return ItemsItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemsItem>, I>>(
    object: I
  ): ItemsItem {
    const message = createBaseItemsItem();
    message.schemaOrReference =
      object.schemaOrReference?.map(e => SchemaOrReference.fromPartial(e)) ||
      [];
    return message;
  }
};

function createBaseLicense(): License {
  return { name: "", url: "", specificationExtension: [] };
}

export const License: MessageFns<License> = {
  encode(
    message: License,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): License {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLicense();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): License {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: License): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<License>, I>>(base?: I): License {
    return License.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<License>, I>>(object: I): License {
    const message = createBaseLicense();
    message.name = object.name ?? "";
    message.url = object.url ?? "";
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseLink(): Link {
  return {
    operationRef: "",
    operationId: "",
    parameters: undefined,
    requestBody: undefined,
    description: "",
    server: undefined,
    specificationExtension: []
  };
}

export const Link: MessageFns<Link> = {
  encode(
    message: Link,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.operationRef !== "") {
      writer.uint32(10).string(message.operationRef);
    }
    if (message.operationId !== "") {
      writer.uint32(18).string(message.operationId);
    }
    if (message.parameters !== undefined) {
      AnyOrExpression.encode(
        message.parameters,
        writer.uint32(26).fork()
      ).join();
    }
    if (message.requestBody !== undefined) {
      AnyOrExpression.encode(
        message.requestBody,
        writer.uint32(34).fork()
      ).join();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.server !== undefined) {
      Server.encode(message.server, writer.uint32(50).fork()).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Link {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operationRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parameters = AnyOrExpression.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requestBody = AnyOrExpression.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.server = Server.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Link {
    return {
      operationRef: isSet(object.operationRef)
        ? globalThis.String(object.operationRef)
        : "",
      operationId: isSet(object.operationId)
        ? globalThis.String(object.operationId)
        : "",
      parameters: isSet(object.parameters)
        ? AnyOrExpression.fromJSON(object.parameters)
        : undefined,
      requestBody: isSet(object.requestBody)
        ? AnyOrExpression.fromJSON(object.requestBody)
        : undefined,
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      server: isSet(object.server) ? Server.fromJSON(object.server) : undefined,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Link): unknown {
    const obj: any = {};
    if (message.operationRef !== "") {
      obj.operationRef = message.operationRef;
    }
    if (message.operationId !== "") {
      obj.operationId = message.operationId;
    }
    if (message.parameters !== undefined) {
      obj.parameters = AnyOrExpression.toJSON(message.parameters);
    }
    if (message.requestBody !== undefined) {
      obj.requestBody = AnyOrExpression.toJSON(message.requestBody);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.server !== undefined) {
      obj.server = Server.toJSON(message.server);
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Link>, I>>(base?: I): Link {
    return Link.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Link>, I>>(object: I): Link {
    const message = createBaseLink();
    message.operationRef = object.operationRef ?? "";
    message.operationId = object.operationId ?? "";
    message.parameters =
      object.parameters !== undefined && object.parameters !== null
        ? AnyOrExpression.fromPartial(object.parameters)
        : undefined;
    message.requestBody =
      object.requestBody !== undefined && object.requestBody !== null
        ? AnyOrExpression.fromPartial(object.requestBody)
        : undefined;
    message.description = object.description ?? "";
    message.server =
      object.server !== undefined && object.server !== null
        ? Server.fromPartial(object.server)
        : undefined;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseLinkOrReference(): LinkOrReference {
  return { link: undefined, reference: undefined };
}

export const LinkOrReference: MessageFns<LinkOrReference> = {
  encode(
    message: LinkOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.link !== undefined) {
      Link.encode(message.link, writer.uint32(10).fork()).join();
    }
    if (message.reference !== undefined) {
      Reference.encode(message.reference, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.link = Link.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = Reference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkOrReference {
    return {
      link: isSet(object.link) ? Link.fromJSON(object.link) : undefined,
      reference: isSet(object.reference)
        ? Reference.fromJSON(object.reference)
        : undefined
    };
  },

  toJSON(message: LinkOrReference): unknown {
    const obj: any = {};
    if (message.link !== undefined) {
      obj.link = Link.toJSON(message.link);
    }
    if (message.reference !== undefined) {
      obj.reference = Reference.toJSON(message.reference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkOrReference>, I>>(
    base?: I
  ): LinkOrReference {
    return LinkOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkOrReference>, I>>(
    object: I
  ): LinkOrReference {
    const message = createBaseLinkOrReference();
    message.link =
      object.link !== undefined && object.link !== null
        ? Link.fromPartial(object.link)
        : undefined;
    message.reference =
      object.reference !== undefined && object.reference !== null
        ? Reference.fromPartial(object.reference)
        : undefined;
    return message;
  }
};

function createBaseLinksOrReferences(): LinksOrReferences {
  return { additionalProperties: [] };
}

export const LinksOrReferences: MessageFns<LinksOrReferences> = {
  encode(
    message: LinksOrReferences,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedLinkOrReference.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinksOrReferences {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinksOrReferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedLinkOrReference.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinksOrReferences {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) =>
            NamedLinkOrReference.fromJSON(e)
          )
        : []
    };
  },

  toJSON(message: LinksOrReferences): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedLinkOrReference.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinksOrReferences>, I>>(
    base?: I
  ): LinksOrReferences {
    return LinksOrReferences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinksOrReferences>, I>>(
    object: I
  ): LinksOrReferences {
    const message = createBaseLinksOrReferences();
    message.additionalProperties =
      object.additionalProperties?.map(e =>
        NamedLinkOrReference.fromPartial(e)
      ) || [];
    return message;
  }
};

function createBaseMediaType(): MediaType {
  return {
    schema: undefined,
    example: undefined,
    examples: undefined,
    encoding: undefined,
    specificationExtension: []
  };
}

export const MediaType: MessageFns<MediaType> = {
  encode(
    message: MediaType,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.schema !== undefined) {
      SchemaOrReference.encode(message.schema, writer.uint32(10).fork()).join();
    }
    if (message.example !== undefined) {
      Any.encode(message.example, writer.uint32(18).fork()).join();
    }
    if (message.examples !== undefined) {
      ExamplesOrReferences.encode(
        message.examples,
        writer.uint32(26).fork()
      ).join();
    }
    if (message.encoding !== undefined) {
      Encodings.encode(message.encoding, writer.uint32(34).fork()).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaType {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schema = SchemaOrReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.example = Any.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.examples = ExamplesOrReferences.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.encoding = Encodings.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediaType {
    return {
      schema: isSet(object.schema)
        ? SchemaOrReference.fromJSON(object.schema)
        : undefined,
      example: isSet(object.example) ? Any.fromJSON(object.example) : undefined,
      examples: isSet(object.examples)
        ? ExamplesOrReferences.fromJSON(object.examples)
        : undefined,
      encoding: isSet(object.encoding)
        ? Encodings.fromJSON(object.encoding)
        : undefined,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: MediaType): unknown {
    const obj: any = {};
    if (message.schema !== undefined) {
      obj.schema = SchemaOrReference.toJSON(message.schema);
    }
    if (message.example !== undefined) {
      obj.example = Any.toJSON(message.example);
    }
    if (message.examples !== undefined) {
      obj.examples = ExamplesOrReferences.toJSON(message.examples);
    }
    if (message.encoding !== undefined) {
      obj.encoding = Encodings.toJSON(message.encoding);
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MediaType>, I>>(base?: I): MediaType {
    return MediaType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MediaType>, I>>(
    object: I
  ): MediaType {
    const message = createBaseMediaType();
    message.schema =
      object.schema !== undefined && object.schema !== null
        ? SchemaOrReference.fromPartial(object.schema)
        : undefined;
    message.example =
      object.example !== undefined && object.example !== null
        ? Any.fromPartial(object.example)
        : undefined;
    message.examples =
      object.examples !== undefined && object.examples !== null
        ? ExamplesOrReferences.fromPartial(object.examples)
        : undefined;
    message.encoding =
      object.encoding !== undefined && object.encoding !== null
        ? Encodings.fromPartial(object.encoding)
        : undefined;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseMediaTypes(): MediaTypes {
  return { additionalProperties: [] };
}

export const MediaTypes: MessageFns<MediaTypes> = {
  encode(
    message: MediaTypes,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedMediaType.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaTypes {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaTypes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedMediaType.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediaTypes {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) =>
            NamedMediaType.fromJSON(e)
          )
        : []
    };
  },

  toJSON(message: MediaTypes): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedMediaType.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MediaTypes>, I>>(base?: I): MediaTypes {
    return MediaTypes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MediaTypes>, I>>(
    object: I
  ): MediaTypes {
    const message = createBaseMediaTypes();
    message.additionalProperties =
      object.additionalProperties?.map(e => NamedMediaType.fromPartial(e)) ||
      [];
    return message;
  }
};

function createBaseNamedAny(): NamedAny {
  return { name: "", value: undefined };
}

export const NamedAny: MessageFns<NamedAny> = {
  encode(
    message: NamedAny,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedAny {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedAny();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedAny {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined
    };
  },

  toJSON(message: NamedAny): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedAny>, I>>(base?: I): NamedAny {
    return NamedAny.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedAny>, I>>(object: I): NamedAny {
    const message = createBaseNamedAny();
    message.name = object.name ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? Any.fromPartial(object.value)
        : undefined;
    return message;
  }
};

function createBaseNamedCallbackOrReference(): NamedCallbackOrReference {
  return { name: "", value: undefined };
}

export const NamedCallbackOrReference: MessageFns<NamedCallbackOrReference> = {
  encode(
    message: NamedCallbackOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      CallbackOrReference.encode(
        message.value,
        writer.uint32(18).fork()
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): NamedCallbackOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedCallbackOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = CallbackOrReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedCallbackOrReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value)
        ? CallbackOrReference.fromJSON(object.value)
        : undefined
    };
  },

  toJSON(message: NamedCallbackOrReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = CallbackOrReference.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedCallbackOrReference>, I>>(
    base?: I
  ): NamedCallbackOrReference {
    return NamedCallbackOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedCallbackOrReference>, I>>(
    object: I
  ): NamedCallbackOrReference {
    const message = createBaseNamedCallbackOrReference();
    message.name = object.name ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? CallbackOrReference.fromPartial(object.value)
        : undefined;
    return message;
  }
};

function createBaseNamedEncoding(): NamedEncoding {
  return { name: "", value: undefined };
}

export const NamedEncoding: MessageFns<NamedEncoding> = {
  encode(
    message: NamedEncoding,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      Encoding.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedEncoding {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedEncoding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Encoding.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedEncoding {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? Encoding.fromJSON(object.value) : undefined
    };
  },

  toJSON(message: NamedEncoding): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = Encoding.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedEncoding>, I>>(
    base?: I
  ): NamedEncoding {
    return NamedEncoding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedEncoding>, I>>(
    object: I
  ): NamedEncoding {
    const message = createBaseNamedEncoding();
    message.name = object.name ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? Encoding.fromPartial(object.value)
        : undefined;
    return message;
  }
};

function createBaseNamedExampleOrReference(): NamedExampleOrReference {
  return { name: "", value: undefined };
}

export const NamedExampleOrReference: MessageFns<NamedExampleOrReference> = {
  encode(
    message: NamedExampleOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      ExampleOrReference.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): NamedExampleOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedExampleOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ExampleOrReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedExampleOrReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value)
        ? ExampleOrReference.fromJSON(object.value)
        : undefined
    };
  },

  toJSON(message: NamedExampleOrReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = ExampleOrReference.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedExampleOrReference>, I>>(
    base?: I
  ): NamedExampleOrReference {
    return NamedExampleOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedExampleOrReference>, I>>(
    object: I
  ): NamedExampleOrReference {
    const message = createBaseNamedExampleOrReference();
    message.name = object.name ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? ExampleOrReference.fromPartial(object.value)
        : undefined;
    return message;
  }
};

function createBaseNamedHeaderOrReference(): NamedHeaderOrReference {
  return { name: "", value: undefined };
}

export const NamedHeaderOrReference: MessageFns<NamedHeaderOrReference> = {
  encode(
    message: NamedHeaderOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      HeaderOrReference.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): NamedHeaderOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedHeaderOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = HeaderOrReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedHeaderOrReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value)
        ? HeaderOrReference.fromJSON(object.value)
        : undefined
    };
  },

  toJSON(message: NamedHeaderOrReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = HeaderOrReference.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedHeaderOrReference>, I>>(
    base?: I
  ): NamedHeaderOrReference {
    return NamedHeaderOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedHeaderOrReference>, I>>(
    object: I
  ): NamedHeaderOrReference {
    const message = createBaseNamedHeaderOrReference();
    message.name = object.name ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? HeaderOrReference.fromPartial(object.value)
        : undefined;
    return message;
  }
};

function createBaseNamedLinkOrReference(): NamedLinkOrReference {
  return { name: "", value: undefined };
}

export const NamedLinkOrReference: MessageFns<NamedLinkOrReference> = {
  encode(
    message: NamedLinkOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      LinkOrReference.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): NamedLinkOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedLinkOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LinkOrReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedLinkOrReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value)
        ? LinkOrReference.fromJSON(object.value)
        : undefined
    };
  },

  toJSON(message: NamedLinkOrReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = LinkOrReference.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedLinkOrReference>, I>>(
    base?: I
  ): NamedLinkOrReference {
    return NamedLinkOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedLinkOrReference>, I>>(
    object: I
  ): NamedLinkOrReference {
    const message = createBaseNamedLinkOrReference();
    message.name = object.name ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? LinkOrReference.fromPartial(object.value)
        : undefined;
    return message;
  }
};

function createBaseNamedMediaType(): NamedMediaType {
  return { name: "", value: undefined };
}

export const NamedMediaType: MessageFns<NamedMediaType> = {
  encode(
    message: NamedMediaType,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      MediaType.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedMediaType {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedMediaType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = MediaType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedMediaType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? MediaType.fromJSON(object.value) : undefined
    };
  },

  toJSON(message: NamedMediaType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = MediaType.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedMediaType>, I>>(
    base?: I
  ): NamedMediaType {
    return NamedMediaType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedMediaType>, I>>(
    object: I
  ): NamedMediaType {
    const message = createBaseNamedMediaType();
    message.name = object.name ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? MediaType.fromPartial(object.value)
        : undefined;
    return message;
  }
};

function createBaseNamedParameterOrReference(): NamedParameterOrReference {
  return { name: "", value: undefined };
}

export const NamedParameterOrReference: MessageFns<NamedParameterOrReference> =
  {
    encode(
      message: NamedParameterOrReference,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.name !== "") {
        writer.uint32(10).string(message.name);
      }
      if (message.value !== undefined) {
        ParameterOrReference.encode(
          message.value,
          writer.uint32(18).fork()
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): NamedParameterOrReference {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseNamedParameterOrReference();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.name = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = ParameterOrReference.decode(
              reader,
              reader.uint32()
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): NamedParameterOrReference {
      return {
        name: isSet(object.name) ? globalThis.String(object.name) : "",
        value: isSet(object.value)
          ? ParameterOrReference.fromJSON(object.value)
          : undefined
      };
    },

    toJSON(message: NamedParameterOrReference): unknown {
      const obj: any = {};
      if (message.name !== "") {
        obj.name = message.name;
      }
      if (message.value !== undefined) {
        obj.value = ParameterOrReference.toJSON(message.value);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<NamedParameterOrReference>, I>>(
      base?: I
    ): NamedParameterOrReference {
      return NamedParameterOrReference.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<NamedParameterOrReference>, I>>(
      object: I
    ): NamedParameterOrReference {
      const message = createBaseNamedParameterOrReference();
      message.name = object.name ?? "";
      message.value =
        object.value !== undefined && object.value !== null
          ? ParameterOrReference.fromPartial(object.value)
          : undefined;
      return message;
    }
  };

function createBaseNamedPathItem(): NamedPathItem {
  return { name: "", value: undefined };
}

export const NamedPathItem: MessageFns<NamedPathItem> = {
  encode(
    message: NamedPathItem,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      PathItem.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedPathItem {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedPathItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = PathItem.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedPathItem {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? PathItem.fromJSON(object.value) : undefined
    };
  },

  toJSON(message: NamedPathItem): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = PathItem.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedPathItem>, I>>(
    base?: I
  ): NamedPathItem {
    return NamedPathItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedPathItem>, I>>(
    object: I
  ): NamedPathItem {
    const message = createBaseNamedPathItem();
    message.name = object.name ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? PathItem.fromPartial(object.value)
        : undefined;
    return message;
  }
};

function createBaseNamedRequestBodyOrReference(): NamedRequestBodyOrReference {
  return { name: "", value: undefined };
}

export const NamedRequestBodyOrReference: MessageFns<NamedRequestBodyOrReference> =
  {
    encode(
      message: NamedRequestBodyOrReference,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.name !== "") {
        writer.uint32(10).string(message.name);
      }
      if (message.value !== undefined) {
        RequestBodyOrReference.encode(
          message.value,
          writer.uint32(18).fork()
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): NamedRequestBodyOrReference {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseNamedRequestBodyOrReference();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.name = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = RequestBodyOrReference.decode(
              reader,
              reader.uint32()
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): NamedRequestBodyOrReference {
      return {
        name: isSet(object.name) ? globalThis.String(object.name) : "",
        value: isSet(object.value)
          ? RequestBodyOrReference.fromJSON(object.value)
          : undefined
      };
    },

    toJSON(message: NamedRequestBodyOrReference): unknown {
      const obj: any = {};
      if (message.name !== "") {
        obj.name = message.name;
      }
      if (message.value !== undefined) {
        obj.value = RequestBodyOrReference.toJSON(message.value);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<NamedRequestBodyOrReference>, I>>(
      base?: I
    ): NamedRequestBodyOrReference {
      return NamedRequestBodyOrReference.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<NamedRequestBodyOrReference>, I>>(
      object: I
    ): NamedRequestBodyOrReference {
      const message = createBaseNamedRequestBodyOrReference();
      message.name = object.name ?? "";
      message.value =
        object.value !== undefined && object.value !== null
          ? RequestBodyOrReference.fromPartial(object.value)
          : undefined;
      return message;
    }
  };

function createBaseNamedResponseOrReference(): NamedResponseOrReference {
  return { name: "", value: undefined };
}

export const NamedResponseOrReference: MessageFns<NamedResponseOrReference> = {
  encode(
    message: NamedResponseOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      ResponseOrReference.encode(
        message.value,
        writer.uint32(18).fork()
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): NamedResponseOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedResponseOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ResponseOrReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedResponseOrReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value)
        ? ResponseOrReference.fromJSON(object.value)
        : undefined
    };
  },

  toJSON(message: NamedResponseOrReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = ResponseOrReference.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedResponseOrReference>, I>>(
    base?: I
  ): NamedResponseOrReference {
    return NamedResponseOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedResponseOrReference>, I>>(
    object: I
  ): NamedResponseOrReference {
    const message = createBaseNamedResponseOrReference();
    message.name = object.name ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? ResponseOrReference.fromPartial(object.value)
        : undefined;
    return message;
  }
};

function createBaseNamedSchemaOrReference(): NamedSchemaOrReference {
  return { name: "", value: undefined };
}

export const NamedSchemaOrReference: MessageFns<NamedSchemaOrReference> = {
  encode(
    message: NamedSchemaOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      SchemaOrReference.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): NamedSchemaOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedSchemaOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SchemaOrReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedSchemaOrReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value)
        ? SchemaOrReference.fromJSON(object.value)
        : undefined
    };
  },

  toJSON(message: NamedSchemaOrReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = SchemaOrReference.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedSchemaOrReference>, I>>(
    base?: I
  ): NamedSchemaOrReference {
    return NamedSchemaOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedSchemaOrReference>, I>>(
    object: I
  ): NamedSchemaOrReference {
    const message = createBaseNamedSchemaOrReference();
    message.name = object.name ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? SchemaOrReference.fromPartial(object.value)
        : undefined;
    return message;
  }
};

function createBaseNamedSecuritySchemeOrReference(): NamedSecuritySchemeOrReference {
  return { name: "", value: undefined };
}

export const NamedSecuritySchemeOrReference: MessageFns<NamedSecuritySchemeOrReference> =
  {
    encode(
      message: NamedSecuritySchemeOrReference,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.name !== "") {
        writer.uint32(10).string(message.name);
      }
      if (message.value !== undefined) {
        SecuritySchemeOrReference.encode(
          message.value,
          writer.uint32(18).fork()
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): NamedSecuritySchemeOrReference {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseNamedSecuritySchemeOrReference();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.name = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = SecuritySchemeOrReference.decode(
              reader,
              reader.uint32()
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): NamedSecuritySchemeOrReference {
      return {
        name: isSet(object.name) ? globalThis.String(object.name) : "",
        value: isSet(object.value)
          ? SecuritySchemeOrReference.fromJSON(object.value)
          : undefined
      };
    },

    toJSON(message: NamedSecuritySchemeOrReference): unknown {
      const obj: any = {};
      if (message.name !== "") {
        obj.name = message.name;
      }
      if (message.value !== undefined) {
        obj.value = SecuritySchemeOrReference.toJSON(message.value);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<NamedSecuritySchemeOrReference>, I>>(
      base?: I
    ): NamedSecuritySchemeOrReference {
      return NamedSecuritySchemeOrReference.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<NamedSecuritySchemeOrReference>, I>
    >(object: I): NamedSecuritySchemeOrReference {
      const message = createBaseNamedSecuritySchemeOrReference();
      message.name = object.name ?? "";
      message.value =
        object.value !== undefined && object.value !== null
          ? SecuritySchemeOrReference.fromPartial(object.value)
          : undefined;
      return message;
    }
  };

function createBaseNamedServerVariable(): NamedServerVariable {
  return { name: "", value: undefined };
}

export const NamedServerVariable: MessageFns<NamedServerVariable> = {
  encode(
    message: NamedServerVariable,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      ServerVariable.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): NamedServerVariable {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedServerVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ServerVariable.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedServerVariable {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value)
        ? ServerVariable.fromJSON(object.value)
        : undefined
    };
  },

  toJSON(message: NamedServerVariable): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = ServerVariable.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedServerVariable>, I>>(
    base?: I
  ): NamedServerVariable {
    return NamedServerVariable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedServerVariable>, I>>(
    object: I
  ): NamedServerVariable {
    const message = createBaseNamedServerVariable();
    message.name = object.name ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? ServerVariable.fromPartial(object.value)
        : undefined;
    return message;
  }
};

function createBaseNamedString(): NamedString {
  return { name: "", value: "" };
}

export const NamedString: MessageFns<NamedString> = {
  encode(
    message: NamedString,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedString {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedString();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedString {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : ""
    };
  },

  toJSON(message: NamedString): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedString>, I>>(base?: I): NamedString {
    return NamedString.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedString>, I>>(
    object: I
  ): NamedString {
    const message = createBaseNamedString();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  }
};

function createBaseNamedStringArray(): NamedStringArray {
  return { name: "", value: undefined };
}

export const NamedStringArray: MessageFns<NamedStringArray> = {
  encode(
    message: NamedStringArray,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      StringArray.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedStringArray {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedStringArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = StringArray.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedStringArray {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value)
        ? StringArray.fromJSON(object.value)
        : undefined
    };
  },

  toJSON(message: NamedStringArray): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = StringArray.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedStringArray>, I>>(
    base?: I
  ): NamedStringArray {
    return NamedStringArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedStringArray>, I>>(
    object: I
  ): NamedStringArray {
    const message = createBaseNamedStringArray();
    message.name = object.name ?? "";
    message.value =
      object.value !== undefined && object.value !== null
        ? StringArray.fromPartial(object.value)
        : undefined;
    return message;
  }
};

function createBaseOauthFlow(): OauthFlow {
  return {
    authorizationUrl: "",
    tokenUrl: "",
    refreshUrl: "",
    scopes: undefined,
    specificationExtension: []
  };
}

export const OauthFlow: MessageFns<OauthFlow> = {
  encode(
    message: OauthFlow,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.authorizationUrl !== "") {
      writer.uint32(10).string(message.authorizationUrl);
    }
    if (message.tokenUrl !== "") {
      writer.uint32(18).string(message.tokenUrl);
    }
    if (message.refreshUrl !== "") {
      writer.uint32(26).string(message.refreshUrl);
    }
    if (message.scopes !== undefined) {
      Strings.encode(message.scopes, writer.uint32(34).fork()).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OauthFlow {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOauthFlow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authorizationUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scopes = Strings.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OauthFlow {
    return {
      authorizationUrl: isSet(object.authorizationUrl)
        ? globalThis.String(object.authorizationUrl)
        : "",
      tokenUrl: isSet(object.tokenUrl)
        ? globalThis.String(object.tokenUrl)
        : "",
      refreshUrl: isSet(object.refreshUrl)
        ? globalThis.String(object.refreshUrl)
        : "",
      scopes: isSet(object.scopes)
        ? Strings.fromJSON(object.scopes)
        : undefined,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: OauthFlow): unknown {
    const obj: any = {};
    if (message.authorizationUrl !== "") {
      obj.authorizationUrl = message.authorizationUrl;
    }
    if (message.tokenUrl !== "") {
      obj.tokenUrl = message.tokenUrl;
    }
    if (message.refreshUrl !== "") {
      obj.refreshUrl = message.refreshUrl;
    }
    if (message.scopes !== undefined) {
      obj.scopes = Strings.toJSON(message.scopes);
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OauthFlow>, I>>(base?: I): OauthFlow {
    return OauthFlow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OauthFlow>, I>>(
    object: I
  ): OauthFlow {
    const message = createBaseOauthFlow();
    message.authorizationUrl = object.authorizationUrl ?? "";
    message.tokenUrl = object.tokenUrl ?? "";
    message.refreshUrl = object.refreshUrl ?? "";
    message.scopes =
      object.scopes !== undefined && object.scopes !== null
        ? Strings.fromPartial(object.scopes)
        : undefined;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseOauthFlows(): OauthFlows {
  return {
    implicit: undefined,
    password: undefined,
    clientCredentials: undefined,
    authorizationCode: undefined,
    specificationExtension: []
  };
}

export const OauthFlows: MessageFns<OauthFlows> = {
  encode(
    message: OauthFlows,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.implicit !== undefined) {
      OauthFlow.encode(message.implicit, writer.uint32(10).fork()).join();
    }
    if (message.password !== undefined) {
      OauthFlow.encode(message.password, writer.uint32(18).fork()).join();
    }
    if (message.clientCredentials !== undefined) {
      OauthFlow.encode(
        message.clientCredentials,
        writer.uint32(26).fork()
      ).join();
    }
    if (message.authorizationCode !== undefined) {
      OauthFlow.encode(
        message.authorizationCode,
        writer.uint32(34).fork()
      ).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OauthFlows {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOauthFlows();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.implicit = OauthFlow.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = OauthFlow.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientCredentials = OauthFlow.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authorizationCode = OauthFlow.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OauthFlows {
    return {
      implicit: isSet(object.implicit)
        ? OauthFlow.fromJSON(object.implicit)
        : undefined,
      password: isSet(object.password)
        ? OauthFlow.fromJSON(object.password)
        : undefined,
      clientCredentials: isSet(object.clientCredentials)
        ? OauthFlow.fromJSON(object.clientCredentials)
        : undefined,
      authorizationCode: isSet(object.authorizationCode)
        ? OauthFlow.fromJSON(object.authorizationCode)
        : undefined,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: OauthFlows): unknown {
    const obj: any = {};
    if (message.implicit !== undefined) {
      obj.implicit = OauthFlow.toJSON(message.implicit);
    }
    if (message.password !== undefined) {
      obj.password = OauthFlow.toJSON(message.password);
    }
    if (message.clientCredentials !== undefined) {
      obj.clientCredentials = OauthFlow.toJSON(message.clientCredentials);
    }
    if (message.authorizationCode !== undefined) {
      obj.authorizationCode = OauthFlow.toJSON(message.authorizationCode);
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OauthFlows>, I>>(base?: I): OauthFlows {
    return OauthFlows.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OauthFlows>, I>>(
    object: I
  ): OauthFlows {
    const message = createBaseOauthFlows();
    message.implicit =
      object.implicit !== undefined && object.implicit !== null
        ? OauthFlow.fromPartial(object.implicit)
        : undefined;
    message.password =
      object.password !== undefined && object.password !== null
        ? OauthFlow.fromPartial(object.password)
        : undefined;
    message.clientCredentials =
      object.clientCredentials !== undefined &&
      object.clientCredentials !== null
        ? OauthFlow.fromPartial(object.clientCredentials)
        : undefined;
    message.authorizationCode =
      object.authorizationCode !== undefined &&
      object.authorizationCode !== null
        ? OauthFlow.fromPartial(object.authorizationCode)
        : undefined;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseObject(): Object {
  return { additionalProperties: [] };
}

export const Object: MessageFns<Object> = {
  encode(
    message: Object,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedAny.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Object {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Object {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Object): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Object>, I>>(base?: I): Object {
    return Object.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Object>, I>>(object: I): Object {
    const message = createBaseObject();
    message.additionalProperties =
      object.additionalProperties?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseOperation(): Operation {
  return {
    tags: [],
    summary: "",
    description: "",
    externalDocs: undefined,
    operationId: "",
    parameters: [],
    requestBody: undefined,
    responses: undefined,
    callbacks: undefined,
    deprecated: false,
    security: [],
    servers: [],
    specificationExtension: []
  };
}

export const Operation: MessageFns<Operation> = {
  encode(
    message: Operation,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.tags) {
      writer.uint32(10).string(v!);
    }
    if (message.summary !== "") {
      writer.uint32(18).string(message.summary);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.externalDocs !== undefined) {
      ExternalDocs.encode(
        message.externalDocs,
        writer.uint32(34).fork()
      ).join();
    }
    if (message.operationId !== "") {
      writer.uint32(42).string(message.operationId);
    }
    for (const v of message.parameters) {
      ParameterOrReference.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.requestBody !== undefined) {
      RequestBodyOrReference.encode(
        message.requestBody,
        writer.uint32(58).fork()
      ).join();
    }
    if (message.responses !== undefined) {
      Responses.encode(message.responses, writer.uint32(66).fork()).join();
    }
    if (message.callbacks !== undefined) {
      CallbacksOrReferences.encode(
        message.callbacks,
        writer.uint32(74).fork()
      ).join();
    }
    if (message.deprecated !== false) {
      writer.uint32(80).bool(message.deprecated);
    }
    for (const v of message.security) {
      SecurityRequirement.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.servers) {
      Server.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.externalDocs = ExternalDocs.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.operationId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.parameters.push(
            ParameterOrReference.decode(reader, reader.uint32())
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.requestBody = RequestBodyOrReference.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.responses = Responses.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.callbacks = CallbacksOrReferences.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.deprecated = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.security.push(
            SecurityRequirement.decode(reader, reader.uint32())
          );
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.servers.push(Server.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation {
    return {
      tags: globalThis.Array.isArray(object?.tags)
        ? object.tags.map((e: any) => globalThis.String(e))
        : [],
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      externalDocs: isSet(object.externalDocs)
        ? ExternalDocs.fromJSON(object.externalDocs)
        : undefined,
      operationId: isSet(object.operationId)
        ? globalThis.String(object.operationId)
        : "",
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => ParameterOrReference.fromJSON(e))
        : [],
      requestBody: isSet(object.requestBody)
        ? RequestBodyOrReference.fromJSON(object.requestBody)
        : undefined,
      responses: isSet(object.responses)
        ? Responses.fromJSON(object.responses)
        : undefined,
      callbacks: isSet(object.callbacks)
        ? CallbacksOrReferences.fromJSON(object.callbacks)
        : undefined,
      deprecated: isSet(object.deprecated)
        ? globalThis.Boolean(object.deprecated)
        : false,
      security: globalThis.Array.isArray(object?.security)
        ? object.security.map((e: any) => SecurityRequirement.fromJSON(e))
        : [],
      servers: globalThis.Array.isArray(object?.servers)
        ? object.servers.map((e: any) => Server.fromJSON(e))
        : [],
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Operation): unknown {
    const obj: any = {};
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.externalDocs !== undefined) {
      obj.externalDocs = ExternalDocs.toJSON(message.externalDocs);
    }
    if (message.operationId !== "") {
      obj.operationId = message.operationId;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map(e =>
        ParameterOrReference.toJSON(e)
      );
    }
    if (message.requestBody !== undefined) {
      obj.requestBody = RequestBodyOrReference.toJSON(message.requestBody);
    }
    if (message.responses !== undefined) {
      obj.responses = Responses.toJSON(message.responses);
    }
    if (message.callbacks !== undefined) {
      obj.callbacks = CallbacksOrReferences.toJSON(message.callbacks);
    }
    if (message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.security?.length) {
      obj.security = message.security.map(e => SecurityRequirement.toJSON(e));
    }
    if (message.servers?.length) {
      obj.servers = message.servers.map(e => Server.toJSON(e));
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation>, I>>(base?: I): Operation {
    return Operation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation>, I>>(
    object: I
  ): Operation {
    const message = createBaseOperation();
    message.tags = object.tags?.map(e => e) || [];
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    message.externalDocs =
      object.externalDocs !== undefined && object.externalDocs !== null
        ? ExternalDocs.fromPartial(object.externalDocs)
        : undefined;
    message.operationId = object.operationId ?? "";
    message.parameters =
      object.parameters?.map(e => ParameterOrReference.fromPartial(e)) || [];
    message.requestBody =
      object.requestBody !== undefined && object.requestBody !== null
        ? RequestBodyOrReference.fromPartial(object.requestBody)
        : undefined;
    message.responses =
      object.responses !== undefined && object.responses !== null
        ? Responses.fromPartial(object.responses)
        : undefined;
    message.callbacks =
      object.callbacks !== undefined && object.callbacks !== null
        ? CallbacksOrReferences.fromPartial(object.callbacks)
        : undefined;
    message.deprecated = object.deprecated ?? false;
    message.security =
      object.security?.map(e => SecurityRequirement.fromPartial(e)) || [];
    message.servers = object.servers?.map(e => Server.fromPartial(e)) || [];
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseParameter(): Parameter {
  return {
    name: "",
    in: "",
    description: "",
    required: false,
    deprecated: false,
    allowEmptyValue: false,
    style: "",
    explode: false,
    allowReserved: false,
    schema: undefined,
    example: undefined,
    examples: undefined,
    content: undefined,
    specificationExtension: []
  };
}

export const Parameter: MessageFns<Parameter> = {
  encode(
    message: Parameter,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.in !== "") {
      writer.uint32(18).string(message.in);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.required !== false) {
      writer.uint32(32).bool(message.required);
    }
    if (message.deprecated !== false) {
      writer.uint32(40).bool(message.deprecated);
    }
    if (message.allowEmptyValue !== false) {
      writer.uint32(48).bool(message.allowEmptyValue);
    }
    if (message.style !== "") {
      writer.uint32(58).string(message.style);
    }
    if (message.explode !== false) {
      writer.uint32(64).bool(message.explode);
    }
    if (message.allowReserved !== false) {
      writer.uint32(72).bool(message.allowReserved);
    }
    if (message.schema !== undefined) {
      SchemaOrReference.encode(message.schema, writer.uint32(82).fork()).join();
    }
    if (message.example !== undefined) {
      Any.encode(message.example, writer.uint32(90).fork()).join();
    }
    if (message.examples !== undefined) {
      ExamplesOrReferences.encode(
        message.examples,
        writer.uint32(98).fork()
      ).join();
    }
    if (message.content !== undefined) {
      MediaTypes.encode(message.content, writer.uint32(106).fork()).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Parameter {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.in = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.deprecated = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.allowEmptyValue = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.style = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.explode = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.allowReserved = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.schema = SchemaOrReference.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.example = Any.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.examples = ExamplesOrReferences.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.content = MediaTypes.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Parameter {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      in: isSet(object.in) ? globalThis.String(object.in) : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      required: isSet(object.required)
        ? globalThis.Boolean(object.required)
        : false,
      deprecated: isSet(object.deprecated)
        ? globalThis.Boolean(object.deprecated)
        : false,
      allowEmptyValue: isSet(object.allowEmptyValue)
        ? globalThis.Boolean(object.allowEmptyValue)
        : false,
      style: isSet(object.style) ? globalThis.String(object.style) : "",
      explode: isSet(object.explode)
        ? globalThis.Boolean(object.explode)
        : false,
      allowReserved: isSet(object.allowReserved)
        ? globalThis.Boolean(object.allowReserved)
        : false,
      schema: isSet(object.schema)
        ? SchemaOrReference.fromJSON(object.schema)
        : undefined,
      example: isSet(object.example) ? Any.fromJSON(object.example) : undefined,
      examples: isSet(object.examples)
        ? ExamplesOrReferences.fromJSON(object.examples)
        : undefined,
      content: isSet(object.content)
        ? MediaTypes.fromJSON(object.content)
        : undefined,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Parameter): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.in !== "") {
      obj.in = message.in;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.allowEmptyValue !== false) {
      obj.allowEmptyValue = message.allowEmptyValue;
    }
    if (message.style !== "") {
      obj.style = message.style;
    }
    if (message.explode !== false) {
      obj.explode = message.explode;
    }
    if (message.allowReserved !== false) {
      obj.allowReserved = message.allowReserved;
    }
    if (message.schema !== undefined) {
      obj.schema = SchemaOrReference.toJSON(message.schema);
    }
    if (message.example !== undefined) {
      obj.example = Any.toJSON(message.example);
    }
    if (message.examples !== undefined) {
      obj.examples = ExamplesOrReferences.toJSON(message.examples);
    }
    if (message.content !== undefined) {
      obj.content = MediaTypes.toJSON(message.content);
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Parameter>, I>>(base?: I): Parameter {
    return Parameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Parameter>, I>>(
    object: I
  ): Parameter {
    const message = createBaseParameter();
    message.name = object.name ?? "";
    message.in = object.in ?? "";
    message.description = object.description ?? "";
    message.required = object.required ?? false;
    message.deprecated = object.deprecated ?? false;
    message.allowEmptyValue = object.allowEmptyValue ?? false;
    message.style = object.style ?? "";
    message.explode = object.explode ?? false;
    message.allowReserved = object.allowReserved ?? false;
    message.schema =
      object.schema !== undefined && object.schema !== null
        ? SchemaOrReference.fromPartial(object.schema)
        : undefined;
    message.example =
      object.example !== undefined && object.example !== null
        ? Any.fromPartial(object.example)
        : undefined;
    message.examples =
      object.examples !== undefined && object.examples !== null
        ? ExamplesOrReferences.fromPartial(object.examples)
        : undefined;
    message.content =
      object.content !== undefined && object.content !== null
        ? MediaTypes.fromPartial(object.content)
        : undefined;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseParameterOrReference(): ParameterOrReference {
  return { parameter: undefined, reference: undefined };
}

export const ParameterOrReference: MessageFns<ParameterOrReference> = {
  encode(
    message: ParameterOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.parameter !== undefined) {
      Parameter.encode(message.parameter, writer.uint32(10).fork()).join();
    }
    if (message.reference !== undefined) {
      Reference.encode(message.reference, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): ParameterOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parameter = Parameter.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = Reference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterOrReference {
    return {
      parameter: isSet(object.parameter)
        ? Parameter.fromJSON(object.parameter)
        : undefined,
      reference: isSet(object.reference)
        ? Reference.fromJSON(object.reference)
        : undefined
    };
  },

  toJSON(message: ParameterOrReference): unknown {
    const obj: any = {};
    if (message.parameter !== undefined) {
      obj.parameter = Parameter.toJSON(message.parameter);
    }
    if (message.reference !== undefined) {
      obj.reference = Reference.toJSON(message.reference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterOrReference>, I>>(
    base?: I
  ): ParameterOrReference {
    return ParameterOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterOrReference>, I>>(
    object: I
  ): ParameterOrReference {
    const message = createBaseParameterOrReference();
    message.parameter =
      object.parameter !== undefined && object.parameter !== null
        ? Parameter.fromPartial(object.parameter)
        : undefined;
    message.reference =
      object.reference !== undefined && object.reference !== null
        ? Reference.fromPartial(object.reference)
        : undefined;
    return message;
  }
};

function createBaseParametersOrReferences(): ParametersOrReferences {
  return { additionalProperties: [] };
}

export const ParametersOrReferences: MessageFns<ParametersOrReferences> = {
  encode(
    message: ParametersOrReferences,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedParameterOrReference.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): ParametersOrReferences {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParametersOrReferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedParameterOrReference.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParametersOrReferences {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) =>
            NamedParameterOrReference.fromJSON(e)
          )
        : []
    };
  },

  toJSON(message: ParametersOrReferences): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedParameterOrReference.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParametersOrReferences>, I>>(
    base?: I
  ): ParametersOrReferences {
    return ParametersOrReferences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParametersOrReferences>, I>>(
    object: I
  ): ParametersOrReferences {
    const message = createBaseParametersOrReferences();
    message.additionalProperties =
      object.additionalProperties?.map(e =>
        NamedParameterOrReference.fromPartial(e)
      ) || [];
    return message;
  }
};

function createBasePathItem(): PathItem {
  return {
    Ref: "",
    summary: "",
    description: "",
    get: undefined,
    put: undefined,
    post: undefined,
    delete: undefined,
    options: undefined,
    head: undefined,
    patch: undefined,
    trace: undefined,
    servers: [],
    parameters: [],
    specificationExtension: []
  };
}

export const PathItem: MessageFns<PathItem> = {
  encode(
    message: PathItem,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.Ref !== "") {
      writer.uint32(10).string(message.Ref);
    }
    if (message.summary !== "") {
      writer.uint32(18).string(message.summary);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.get !== undefined) {
      Operation.encode(message.get, writer.uint32(34).fork()).join();
    }
    if (message.put !== undefined) {
      Operation.encode(message.put, writer.uint32(42).fork()).join();
    }
    if (message.post !== undefined) {
      Operation.encode(message.post, writer.uint32(50).fork()).join();
    }
    if (message.delete !== undefined) {
      Operation.encode(message.delete, writer.uint32(58).fork()).join();
    }
    if (message.options !== undefined) {
      Operation.encode(message.options, writer.uint32(66).fork()).join();
    }
    if (message.head !== undefined) {
      Operation.encode(message.head, writer.uint32(74).fork()).join();
    }
    if (message.patch !== undefined) {
      Operation.encode(message.patch, writer.uint32(82).fork()).join();
    }
    if (message.trace !== undefined) {
      Operation.encode(message.trace, writer.uint32(90).fork()).join();
    }
    for (const v of message.servers) {
      Server.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.parameters) {
      ParameterOrReference.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PathItem {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePathItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Ref = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.get = Operation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.put = Operation.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.post = Operation.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.delete = Operation.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.options = Operation.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.head = Operation.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.patch = Operation.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.trace = Operation.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.servers.push(Server.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.parameters.push(
            ParameterOrReference.decode(reader, reader.uint32())
          );
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PathItem {
    return {
      Ref: isSet(object.Ref) ? globalThis.String(object.Ref) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      get: isSet(object.get) ? Operation.fromJSON(object.get) : undefined,
      put: isSet(object.put) ? Operation.fromJSON(object.put) : undefined,
      post: isSet(object.post) ? Operation.fromJSON(object.post) : undefined,
      delete: isSet(object.delete)
        ? Operation.fromJSON(object.delete)
        : undefined,
      options: isSet(object.options)
        ? Operation.fromJSON(object.options)
        : undefined,
      head: isSet(object.head) ? Operation.fromJSON(object.head) : undefined,
      patch: isSet(object.patch) ? Operation.fromJSON(object.patch) : undefined,
      trace: isSet(object.trace) ? Operation.fromJSON(object.trace) : undefined,
      servers: globalThis.Array.isArray(object?.servers)
        ? object.servers.map((e: any) => Server.fromJSON(e))
        : [],
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => ParameterOrReference.fromJSON(e))
        : [],
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: PathItem): unknown {
    const obj: any = {};
    if (message.Ref !== "") {
      obj.Ref = message.Ref;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.get !== undefined) {
      obj.get = Operation.toJSON(message.get);
    }
    if (message.put !== undefined) {
      obj.put = Operation.toJSON(message.put);
    }
    if (message.post !== undefined) {
      obj.post = Operation.toJSON(message.post);
    }
    if (message.delete !== undefined) {
      obj.delete = Operation.toJSON(message.delete);
    }
    if (message.options !== undefined) {
      obj.options = Operation.toJSON(message.options);
    }
    if (message.head !== undefined) {
      obj.head = Operation.toJSON(message.head);
    }
    if (message.patch !== undefined) {
      obj.patch = Operation.toJSON(message.patch);
    }
    if (message.trace !== undefined) {
      obj.trace = Operation.toJSON(message.trace);
    }
    if (message.servers?.length) {
      obj.servers = message.servers.map(e => Server.toJSON(e));
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map(e =>
        ParameterOrReference.toJSON(e)
      );
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PathItem>, I>>(base?: I): PathItem {
    return PathItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PathItem>, I>>(object: I): PathItem {
    const message = createBasePathItem();
    message.Ref = object.Ref ?? "";
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    message.get =
      object.get !== undefined && object.get !== null
        ? Operation.fromPartial(object.get)
        : undefined;
    message.put =
      object.put !== undefined && object.put !== null
        ? Operation.fromPartial(object.put)
        : undefined;
    message.post =
      object.post !== undefined && object.post !== null
        ? Operation.fromPartial(object.post)
        : undefined;
    message.delete =
      object.delete !== undefined && object.delete !== null
        ? Operation.fromPartial(object.delete)
        : undefined;
    message.options =
      object.options !== undefined && object.options !== null
        ? Operation.fromPartial(object.options)
        : undefined;
    message.head =
      object.head !== undefined && object.head !== null
        ? Operation.fromPartial(object.head)
        : undefined;
    message.patch =
      object.patch !== undefined && object.patch !== null
        ? Operation.fromPartial(object.patch)
        : undefined;
    message.trace =
      object.trace !== undefined && object.trace !== null
        ? Operation.fromPartial(object.trace)
        : undefined;
    message.servers = object.servers?.map(e => Server.fromPartial(e)) || [];
    message.parameters =
      object.parameters?.map(e => ParameterOrReference.fromPartial(e)) || [];
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBasePaths(): Paths {
  return { path: [], specificationExtension: [] };
}

export const Paths: MessageFns<Paths> = {
  encode(
    message: Paths,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.path) {
      NamedPathItem.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Paths {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaths();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path.push(NamedPathItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Paths {
    return {
      path: globalThis.Array.isArray(object?.path)
        ? object.path.map((e: any) => NamedPathItem.fromJSON(e))
        : [],
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Paths): unknown {
    const obj: any = {};
    if (message.path?.length) {
      obj.path = message.path.map(e => NamedPathItem.toJSON(e));
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Paths>, I>>(base?: I): Paths {
    return Paths.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Paths>, I>>(object: I): Paths {
    const message = createBasePaths();
    message.path = object.path?.map(e => NamedPathItem.fromPartial(e)) || [];
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseProperties(): Properties {
  return { additionalProperties: [] };
}

export const Properties: MessageFns<Properties> = {
  encode(
    message: Properties,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedSchemaOrReference.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Properties {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedSchemaOrReference.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Properties {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) =>
            NamedSchemaOrReference.fromJSON(e)
          )
        : []
    };
  },

  toJSON(message: Properties): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedSchemaOrReference.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Properties>, I>>(base?: I): Properties {
    return Properties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Properties>, I>>(
    object: I
  ): Properties {
    const message = createBaseProperties();
    message.additionalProperties =
      object.additionalProperties?.map(e =>
        NamedSchemaOrReference.fromPartial(e)
      ) || [];
    return message;
  }
};

function createBaseReference(): Reference {
  return { Ref: "", summary: "", description: "" };
}

export const Reference: MessageFns<Reference> = {
  encode(
    message: Reference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.Ref !== "") {
      writer.uint32(10).string(message.Ref);
    }
    if (message.summary !== "") {
      writer.uint32(18).string(message.summary);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Ref = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reference {
    return {
      Ref: isSet(object.Ref) ? globalThis.String(object.Ref) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : ""
    };
  },

  toJSON(message: Reference): unknown {
    const obj: any = {};
    if (message.Ref !== "") {
      obj.Ref = message.Ref;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Reference>, I>>(base?: I): Reference {
    return Reference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Reference>, I>>(
    object: I
  ): Reference {
    const message = createBaseReference();
    message.Ref = object.Ref ?? "";
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    return message;
  }
};

function createBaseRequestBodiesOrReferences(): RequestBodiesOrReferences {
  return { additionalProperties: [] };
}

export const RequestBodiesOrReferences: MessageFns<RequestBodiesOrReferences> =
  {
    encode(
      message: RequestBodiesOrReferences,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      for (const v of message.additionalProperties) {
        NamedRequestBodyOrReference.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): RequestBodiesOrReferences {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseRequestBodiesOrReferences();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.additionalProperties.push(
              NamedRequestBodyOrReference.decode(reader, reader.uint32())
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): RequestBodiesOrReferences {
      return {
        additionalProperties: globalThis.Array.isArray(
          object?.additionalProperties
        )
          ? object.additionalProperties.map((e: any) =>
              NamedRequestBodyOrReference.fromJSON(e)
            )
          : []
      };
    },

    toJSON(message: RequestBodiesOrReferences): unknown {
      const obj: any = {};
      if (message.additionalProperties?.length) {
        obj.additionalProperties = message.additionalProperties.map(e =>
          NamedRequestBodyOrReference.toJSON(e)
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<RequestBodiesOrReferences>, I>>(
      base?: I
    ): RequestBodiesOrReferences {
      return RequestBodiesOrReferences.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<RequestBodiesOrReferences>, I>>(
      object: I
    ): RequestBodiesOrReferences {
      const message = createBaseRequestBodiesOrReferences();
      message.additionalProperties =
        object.additionalProperties?.map(e =>
          NamedRequestBodyOrReference.fromPartial(e)
        ) || [];
      return message;
    }
  };

function createBaseRequestBody(): RequestBody {
  return {
    description: "",
    content: undefined,
    required: false,
    specificationExtension: []
  };
}

export const RequestBody: MessageFns<RequestBody> = {
  encode(
    message: RequestBody,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.content !== undefined) {
      MediaTypes.encode(message.content, writer.uint32(18).fork()).join();
    }
    if (message.required !== false) {
      writer.uint32(24).bool(message.required);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestBody {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = MediaTypes.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestBody {
    return {
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      content: isSet(object.content)
        ? MediaTypes.fromJSON(object.content)
        : undefined,
      required: isSet(object.required)
        ? globalThis.Boolean(object.required)
        : false,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: RequestBody): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.content !== undefined) {
      obj.content = MediaTypes.toJSON(message.content);
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestBody>, I>>(base?: I): RequestBody {
    return RequestBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestBody>, I>>(
    object: I
  ): RequestBody {
    const message = createBaseRequestBody();
    message.description = object.description ?? "";
    message.content =
      object.content !== undefined && object.content !== null
        ? MediaTypes.fromPartial(object.content)
        : undefined;
    message.required = object.required ?? false;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseRequestBodyOrReference(): RequestBodyOrReference {
  return { requestBody: undefined, reference: undefined };
}

export const RequestBodyOrReference: MessageFns<RequestBodyOrReference> = {
  encode(
    message: RequestBodyOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.requestBody !== undefined) {
      RequestBody.encode(message.requestBody, writer.uint32(10).fork()).join();
    }
    if (message.reference !== undefined) {
      Reference.encode(message.reference, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): RequestBodyOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestBodyOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestBody = RequestBody.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = Reference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestBodyOrReference {
    return {
      requestBody: isSet(object.requestBody)
        ? RequestBody.fromJSON(object.requestBody)
        : undefined,
      reference: isSet(object.reference)
        ? Reference.fromJSON(object.reference)
        : undefined
    };
  },

  toJSON(message: RequestBodyOrReference): unknown {
    const obj: any = {};
    if (message.requestBody !== undefined) {
      obj.requestBody = RequestBody.toJSON(message.requestBody);
    }
    if (message.reference !== undefined) {
      obj.reference = Reference.toJSON(message.reference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestBodyOrReference>, I>>(
    base?: I
  ): RequestBodyOrReference {
    return RequestBodyOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestBodyOrReference>, I>>(
    object: I
  ): RequestBodyOrReference {
    const message = createBaseRequestBodyOrReference();
    message.requestBody =
      object.requestBody !== undefined && object.requestBody !== null
        ? RequestBody.fromPartial(object.requestBody)
        : undefined;
    message.reference =
      object.reference !== undefined && object.reference !== null
        ? Reference.fromPartial(object.reference)
        : undefined;
    return message;
  }
};

function createBaseResponse(): Response {
  return {
    description: "",
    headers: undefined,
    content: undefined,
    links: undefined,
    specificationExtension: []
  };
}

export const Response: MessageFns<Response> = {
  encode(
    message: Response,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.headers !== undefined) {
      HeadersOrReferences.encode(
        message.headers,
        writer.uint32(18).fork()
      ).join();
    }
    if (message.content !== undefined) {
      MediaTypes.encode(message.content, writer.uint32(26).fork()).join();
    }
    if (message.links !== undefined) {
      LinksOrReferences.encode(message.links, writer.uint32(34).fork()).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Response {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.headers = HeadersOrReferences.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = MediaTypes.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.links = LinksOrReferences.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Response {
    return {
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      headers: isSet(object.headers)
        ? HeadersOrReferences.fromJSON(object.headers)
        : undefined,
      content: isSet(object.content)
        ? MediaTypes.fromJSON(object.content)
        : undefined,
      links: isSet(object.links)
        ? LinksOrReferences.fromJSON(object.links)
        : undefined,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Response): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.headers !== undefined) {
      obj.headers = HeadersOrReferences.toJSON(message.headers);
    }
    if (message.content !== undefined) {
      obj.content = MediaTypes.toJSON(message.content);
    }
    if (message.links !== undefined) {
      obj.links = LinksOrReferences.toJSON(message.links);
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Response>, I>>(base?: I): Response {
    return Response.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Response>, I>>(object: I): Response {
    const message = createBaseResponse();
    message.description = object.description ?? "";
    message.headers =
      object.headers !== undefined && object.headers !== null
        ? HeadersOrReferences.fromPartial(object.headers)
        : undefined;
    message.content =
      object.content !== undefined && object.content !== null
        ? MediaTypes.fromPartial(object.content)
        : undefined;
    message.links =
      object.links !== undefined && object.links !== null
        ? LinksOrReferences.fromPartial(object.links)
        : undefined;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseResponseOrReference(): ResponseOrReference {
  return { response: undefined, reference: undefined };
}

export const ResponseOrReference: MessageFns<ResponseOrReference> = {
  encode(
    message: ResponseOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.response !== undefined) {
      Response.encode(message.response, writer.uint32(10).fork()).join();
    }
    if (message.reference !== undefined) {
      Reference.encode(message.reference, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): ResponseOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = Response.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = Reference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseOrReference {
    return {
      response: isSet(object.response)
        ? Response.fromJSON(object.response)
        : undefined,
      reference: isSet(object.reference)
        ? Reference.fromJSON(object.reference)
        : undefined
    };
  },

  toJSON(message: ResponseOrReference): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = Response.toJSON(message.response);
    }
    if (message.reference !== undefined) {
      obj.reference = Reference.toJSON(message.reference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseOrReference>, I>>(
    base?: I
  ): ResponseOrReference {
    return ResponseOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseOrReference>, I>>(
    object: I
  ): ResponseOrReference {
    const message = createBaseResponseOrReference();
    message.response =
      object.response !== undefined && object.response !== null
        ? Response.fromPartial(object.response)
        : undefined;
    message.reference =
      object.reference !== undefined && object.reference !== null
        ? Reference.fromPartial(object.reference)
        : undefined;
    return message;
  }
};

function createBaseResponses(): Responses {
  return {
    default: undefined,
    responseOrReference: [],
    specificationExtension: []
  };
}

export const Responses: MessageFns<Responses> = {
  encode(
    message: Responses,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.default !== undefined) {
      ResponseOrReference.encode(
        message.default,
        writer.uint32(10).fork()
      ).join();
    }
    for (const v of message.responseOrReference) {
      NamedResponseOrReference.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Responses {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.default = ResponseOrReference.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.responseOrReference.push(
            NamedResponseOrReference.decode(reader, reader.uint32())
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Responses {
    return {
      default: isSet(object.default)
        ? ResponseOrReference.fromJSON(object.default)
        : undefined,
      responseOrReference: globalThis.Array.isArray(object?.responseOrReference)
        ? object.responseOrReference.map((e: any) =>
            NamedResponseOrReference.fromJSON(e)
          )
        : [],
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Responses): unknown {
    const obj: any = {};
    if (message.default !== undefined) {
      obj.default = ResponseOrReference.toJSON(message.default);
    }
    if (message.responseOrReference?.length) {
      obj.responseOrReference = message.responseOrReference.map(e =>
        NamedResponseOrReference.toJSON(e)
      );
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Responses>, I>>(base?: I): Responses {
    return Responses.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Responses>, I>>(
    object: I
  ): Responses {
    const message = createBaseResponses();
    message.default =
      object.default !== undefined && object.default !== null
        ? ResponseOrReference.fromPartial(object.default)
        : undefined;
    message.responseOrReference =
      object.responseOrReference?.map(e =>
        NamedResponseOrReference.fromPartial(e)
      ) || [];
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseResponsesOrReferences(): ResponsesOrReferences {
  return { additionalProperties: [] };
}

export const ResponsesOrReferences: MessageFns<ResponsesOrReferences> = {
  encode(
    message: ResponsesOrReferences,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedResponseOrReference.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): ResponsesOrReferences {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponsesOrReferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedResponseOrReference.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponsesOrReferences {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) =>
            NamedResponseOrReference.fromJSON(e)
          )
        : []
    };
  },

  toJSON(message: ResponsesOrReferences): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedResponseOrReference.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponsesOrReferences>, I>>(
    base?: I
  ): ResponsesOrReferences {
    return ResponsesOrReferences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponsesOrReferences>, I>>(
    object: I
  ): ResponsesOrReferences {
    const message = createBaseResponsesOrReferences();
    message.additionalProperties =
      object.additionalProperties?.map(e =>
        NamedResponseOrReference.fromPartial(e)
      ) || [];
    return message;
  }
};

function createBaseSchema(): Schema {
  return {
    nullable: false,
    discriminator: undefined,
    readOnly: false,
    writeOnly: false,
    xml: undefined,
    externalDocs: undefined,
    example: undefined,
    deprecated: false,
    title: "",
    multipleOf: 0,
    maximum: 0,
    exclusiveMaximum: false,
    minimum: 0,
    exclusiveMinimum: false,
    maxLength: 0,
    minLength: 0,
    pattern: "",
    maxItems: 0,
    minItems: 0,
    uniqueItems: false,
    maxProperties: 0,
    minProperties: 0,
    required: [],
    enum: [],
    type: "",
    allOf: [],
    oneOf: [],
    anyOf: [],
    not: undefined,
    items: undefined,
    properties: undefined,
    additionalProperties: undefined,
    default: undefined,
    description: "",
    format: "",
    specificationExtension: []
  };
}

export const Schema: MessageFns<Schema> = {
  encode(
    message: Schema,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.nullable !== false) {
      writer.uint32(8).bool(message.nullable);
    }
    if (message.discriminator !== undefined) {
      Discriminator.encode(
        message.discriminator,
        writer.uint32(18).fork()
      ).join();
    }
    if (message.readOnly !== false) {
      writer.uint32(24).bool(message.readOnly);
    }
    if (message.writeOnly !== false) {
      writer.uint32(32).bool(message.writeOnly);
    }
    if (message.xml !== undefined) {
      Xml.encode(message.xml, writer.uint32(42).fork()).join();
    }
    if (message.externalDocs !== undefined) {
      ExternalDocs.encode(
        message.externalDocs,
        writer.uint32(50).fork()
      ).join();
    }
    if (message.example !== undefined) {
      Any.encode(message.example, writer.uint32(58).fork()).join();
    }
    if (message.deprecated !== false) {
      writer.uint32(64).bool(message.deprecated);
    }
    if (message.title !== "") {
      writer.uint32(74).string(message.title);
    }
    if (message.multipleOf !== 0) {
      writer.uint32(81).double(message.multipleOf);
    }
    if (message.maximum !== 0) {
      writer.uint32(89).double(message.maximum);
    }
    if (message.exclusiveMaximum !== false) {
      writer.uint32(96).bool(message.exclusiveMaximum);
    }
    if (message.minimum !== 0) {
      writer.uint32(105).double(message.minimum);
    }
    if (message.exclusiveMinimum !== false) {
      writer.uint32(112).bool(message.exclusiveMinimum);
    }
    if (message.maxLength !== 0) {
      writer.uint32(120).int64(message.maxLength);
    }
    if (message.minLength !== 0) {
      writer.uint32(128).int64(message.minLength);
    }
    if (message.pattern !== "") {
      writer.uint32(138).string(message.pattern);
    }
    if (message.maxItems !== 0) {
      writer.uint32(144).int64(message.maxItems);
    }
    if (message.minItems !== 0) {
      writer.uint32(152).int64(message.minItems);
    }
    if (message.uniqueItems !== false) {
      writer.uint32(160).bool(message.uniqueItems);
    }
    if (message.maxProperties !== 0) {
      writer.uint32(168).int64(message.maxProperties);
    }
    if (message.minProperties !== 0) {
      writer.uint32(176).int64(message.minProperties);
    }
    for (const v of message.required) {
      writer.uint32(186).string(v!);
    }
    for (const v of message.enum) {
      Any.encode(v!, writer.uint32(194).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(202).string(message.type);
    }
    for (const v of message.allOf) {
      SchemaOrReference.encode(v!, writer.uint32(210).fork()).join();
    }
    for (const v of message.oneOf) {
      SchemaOrReference.encode(v!, writer.uint32(218).fork()).join();
    }
    for (const v of message.anyOf) {
      SchemaOrReference.encode(v!, writer.uint32(226).fork()).join();
    }
    if (message.not !== undefined) {
      Schema.encode(message.not, writer.uint32(234).fork()).join();
    }
    if (message.items !== undefined) {
      ItemsItem.encode(message.items, writer.uint32(242).fork()).join();
    }
    if (message.properties !== undefined) {
      Properties.encode(message.properties, writer.uint32(250).fork()).join();
    }
    if (message.additionalProperties !== undefined) {
      AdditionalPropertiesItem.encode(
        message.additionalProperties,
        writer.uint32(258).fork()
      ).join();
    }
    if (message.default !== undefined) {
      DefaultType.encode(message.default, writer.uint32(266).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(274).string(message.description);
    }
    if (message.format !== "") {
      writer.uint32(282).string(message.format);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(290).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schema {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.discriminator = Discriminator.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.readOnly = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.writeOnly = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.xml = Xml.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.externalDocs = ExternalDocs.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.example = Any.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.deprecated = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.multipleOf = reader.double();
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.maximum = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.exclusiveMaximum = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 105) {
            break;
          }

          message.minimum = reader.double();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.exclusiveMinimum = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.maxLength = longToNumber(reader.int64());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.minLength = longToNumber(reader.int64());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.pattern = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.maxItems = longToNumber(reader.int64());
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.minItems = longToNumber(reader.int64());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.uniqueItems = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.maxProperties = longToNumber(reader.int64());
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.minProperties = longToNumber(reader.int64());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.required.push(reader.string());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.enum.push(Any.decode(reader, reader.uint32()));
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.allOf.push(SchemaOrReference.decode(reader, reader.uint32()));
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.oneOf.push(SchemaOrReference.decode(reader, reader.uint32()));
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.anyOf.push(SchemaOrReference.decode(reader, reader.uint32()));
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.not = Schema.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.items = ItemsItem.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.properties = Properties.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.additionalProperties = AdditionalPropertiesItem.decode(
            reader,
            reader.uint32()
          );
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.default = DefaultType.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema {
    return {
      nullable: isSet(object.nullable)
        ? globalThis.Boolean(object.nullable)
        : false,
      discriminator: isSet(object.discriminator)
        ? Discriminator.fromJSON(object.discriminator)
        : undefined,
      readOnly: isSet(object.readOnly)
        ? globalThis.Boolean(object.readOnly)
        : false,
      writeOnly: isSet(object.writeOnly)
        ? globalThis.Boolean(object.writeOnly)
        : false,
      xml: isSet(object.xml) ? Xml.fromJSON(object.xml) : undefined,
      externalDocs: isSet(object.externalDocs)
        ? ExternalDocs.fromJSON(object.externalDocs)
        : undefined,
      example: isSet(object.example) ? Any.fromJSON(object.example) : undefined,
      deprecated: isSet(object.deprecated)
        ? globalThis.Boolean(object.deprecated)
        : false,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      multipleOf: isSet(object.multipleOf)
        ? globalThis.Number(object.multipleOf)
        : 0,
      maximum: isSet(object.maximum) ? globalThis.Number(object.maximum) : 0,
      exclusiveMaximum: isSet(object.exclusiveMaximum)
        ? globalThis.Boolean(object.exclusiveMaximum)
        : false,
      minimum: isSet(object.minimum) ? globalThis.Number(object.minimum) : 0,
      exclusiveMinimum: isSet(object.exclusiveMinimum)
        ? globalThis.Boolean(object.exclusiveMinimum)
        : false,
      maxLength: isSet(object.maxLength)
        ? globalThis.Number(object.maxLength)
        : 0,
      minLength: isSet(object.minLength)
        ? globalThis.Number(object.minLength)
        : 0,
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
      maxItems: isSet(object.maxItems) ? globalThis.Number(object.maxItems) : 0,
      minItems: isSet(object.minItems) ? globalThis.Number(object.minItems) : 0,
      uniqueItems: isSet(object.uniqueItems)
        ? globalThis.Boolean(object.uniqueItems)
        : false,
      maxProperties: isSet(object.maxProperties)
        ? globalThis.Number(object.maxProperties)
        : 0,
      minProperties: isSet(object.minProperties)
        ? globalThis.Number(object.minProperties)
        : 0,
      required: globalThis.Array.isArray(object?.required)
        ? object.required.map((e: any) => globalThis.String(e))
        : [],
      enum: globalThis.Array.isArray(object?.enum)
        ? object.enum.map((e: any) => Any.fromJSON(e))
        : [],
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      allOf: globalThis.Array.isArray(object?.allOf)
        ? object.allOf.map((e: any) => SchemaOrReference.fromJSON(e))
        : [],
      oneOf: globalThis.Array.isArray(object?.oneOf)
        ? object.oneOf.map((e: any) => SchemaOrReference.fromJSON(e))
        : [],
      anyOf: globalThis.Array.isArray(object?.anyOf)
        ? object.anyOf.map((e: any) => SchemaOrReference.fromJSON(e))
        : [],
      not: isSet(object.not) ? Schema.fromJSON(object.not) : undefined,
      items: isSet(object.items) ? ItemsItem.fromJSON(object.items) : undefined,
      properties: isSet(object.properties)
        ? Properties.fromJSON(object.properties)
        : undefined,
      additionalProperties: isSet(object.additionalProperties)
        ? AdditionalPropertiesItem.fromJSON(object.additionalProperties)
        : undefined,
      default: isSet(object.default)
        ? DefaultType.fromJSON(object.default)
        : undefined,
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Schema): unknown {
    const obj: any = {};
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.discriminator !== undefined) {
      obj.discriminator = Discriminator.toJSON(message.discriminator);
    }
    if (message.readOnly !== false) {
      obj.readOnly = message.readOnly;
    }
    if (message.writeOnly !== false) {
      obj.writeOnly = message.writeOnly;
    }
    if (message.xml !== undefined) {
      obj.xml = Xml.toJSON(message.xml);
    }
    if (message.externalDocs !== undefined) {
      obj.externalDocs = ExternalDocs.toJSON(message.externalDocs);
    }
    if (message.example !== undefined) {
      obj.example = Any.toJSON(message.example);
    }
    if (message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.multipleOf !== 0) {
      obj.multipleOf = message.multipleOf;
    }
    if (message.maximum !== 0) {
      obj.maximum = message.maximum;
    }
    if (message.exclusiveMaximum !== false) {
      obj.exclusiveMaximum = message.exclusiveMaximum;
    }
    if (message.minimum !== 0) {
      obj.minimum = message.minimum;
    }
    if (message.exclusiveMinimum !== false) {
      obj.exclusiveMinimum = message.exclusiveMinimum;
    }
    if (message.maxLength !== 0) {
      obj.maxLength = Math.round(message.maxLength);
    }
    if (message.minLength !== 0) {
      obj.minLength = Math.round(message.minLength);
    }
    if (message.pattern !== "") {
      obj.pattern = message.pattern;
    }
    if (message.maxItems !== 0) {
      obj.maxItems = Math.round(message.maxItems);
    }
    if (message.minItems !== 0) {
      obj.minItems = Math.round(message.minItems);
    }
    if (message.uniqueItems !== false) {
      obj.uniqueItems = message.uniqueItems;
    }
    if (message.maxProperties !== 0) {
      obj.maxProperties = Math.round(message.maxProperties);
    }
    if (message.minProperties !== 0) {
      obj.minProperties = Math.round(message.minProperties);
    }
    if (message.required?.length) {
      obj.required = message.required;
    }
    if (message.enum?.length) {
      obj.enum = message.enum.map(e => Any.toJSON(e));
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.allOf?.length) {
      obj.allOf = message.allOf.map(e => SchemaOrReference.toJSON(e));
    }
    if (message.oneOf?.length) {
      obj.oneOf = message.oneOf.map(e => SchemaOrReference.toJSON(e));
    }
    if (message.anyOf?.length) {
      obj.anyOf = message.anyOf.map(e => SchemaOrReference.toJSON(e));
    }
    if (message.not !== undefined) {
      obj.not = Schema.toJSON(message.not);
    }
    if (message.items !== undefined) {
      obj.items = ItemsItem.toJSON(message.items);
    }
    if (message.properties !== undefined) {
      obj.properties = Properties.toJSON(message.properties);
    }
    if (message.additionalProperties !== undefined) {
      obj.additionalProperties = AdditionalPropertiesItem.toJSON(
        message.additionalProperties
      );
    }
    if (message.default !== undefined) {
      obj.default = DefaultType.toJSON(message.default);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Schema>, I>>(base?: I): Schema {
    return Schema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Schema>, I>>(object: I): Schema {
    const message = createBaseSchema();
    message.nullable = object.nullable ?? false;
    message.discriminator =
      object.discriminator !== undefined && object.discriminator !== null
        ? Discriminator.fromPartial(object.discriminator)
        : undefined;
    message.readOnly = object.readOnly ?? false;
    message.writeOnly = object.writeOnly ?? false;
    message.xml =
      object.xml !== undefined && object.xml !== null
        ? Xml.fromPartial(object.xml)
        : undefined;
    message.externalDocs =
      object.externalDocs !== undefined && object.externalDocs !== null
        ? ExternalDocs.fromPartial(object.externalDocs)
        : undefined;
    message.example =
      object.example !== undefined && object.example !== null
        ? Any.fromPartial(object.example)
        : undefined;
    message.deprecated = object.deprecated ?? false;
    message.title = object.title ?? "";
    message.multipleOf = object.multipleOf ?? 0;
    message.maximum = object.maximum ?? 0;
    message.exclusiveMaximum = object.exclusiveMaximum ?? false;
    message.minimum = object.minimum ?? 0;
    message.exclusiveMinimum = object.exclusiveMinimum ?? false;
    message.maxLength = object.maxLength ?? 0;
    message.minLength = object.minLength ?? 0;
    message.pattern = object.pattern ?? "";
    message.maxItems = object.maxItems ?? 0;
    message.minItems = object.minItems ?? 0;
    message.uniqueItems = object.uniqueItems ?? false;
    message.maxProperties = object.maxProperties ?? 0;
    message.minProperties = object.minProperties ?? 0;
    message.required = object.required?.map(e => e) || [];
    message.enum = object.enum?.map(e => Any.fromPartial(e)) || [];
    message.type = object.type ?? "";
    message.allOf =
      object.allOf?.map(e => SchemaOrReference.fromPartial(e)) || [];
    message.oneOf =
      object.oneOf?.map(e => SchemaOrReference.fromPartial(e)) || [];
    message.anyOf =
      object.anyOf?.map(e => SchemaOrReference.fromPartial(e)) || [];
    message.not =
      object.not !== undefined && object.not !== null
        ? Schema.fromPartial(object.not)
        : undefined;
    message.items =
      object.items !== undefined && object.items !== null
        ? ItemsItem.fromPartial(object.items)
        : undefined;
    message.properties =
      object.properties !== undefined && object.properties !== null
        ? Properties.fromPartial(object.properties)
        : undefined;
    message.additionalProperties =
      object.additionalProperties !== undefined &&
      object.additionalProperties !== null
        ? AdditionalPropertiesItem.fromPartial(object.additionalProperties)
        : undefined;
    message.default =
      object.default !== undefined && object.default !== null
        ? DefaultType.fromPartial(object.default)
        : undefined;
    message.description = object.description ?? "";
    message.format = object.format ?? "";
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseSchemaOrReference(): SchemaOrReference {
  return { schema: undefined, reference: undefined };
}

export const SchemaOrReference: MessageFns<SchemaOrReference> = {
  encode(
    message: SchemaOrReference,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.schema !== undefined) {
      Schema.encode(message.schema, writer.uint32(10).fork()).join();
    }
    if (message.reference !== undefined) {
      Reference.encode(message.reference, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchemaOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schema = Schema.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = Reference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaOrReference {
    return {
      schema: isSet(object.schema) ? Schema.fromJSON(object.schema) : undefined,
      reference: isSet(object.reference)
        ? Reference.fromJSON(object.reference)
        : undefined
    };
  },

  toJSON(message: SchemaOrReference): unknown {
    const obj: any = {};
    if (message.schema !== undefined) {
      obj.schema = Schema.toJSON(message.schema);
    }
    if (message.reference !== undefined) {
      obj.reference = Reference.toJSON(message.reference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SchemaOrReference>, I>>(
    base?: I
  ): SchemaOrReference {
    return SchemaOrReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SchemaOrReference>, I>>(
    object: I
  ): SchemaOrReference {
    const message = createBaseSchemaOrReference();
    message.schema =
      object.schema !== undefined && object.schema !== null
        ? Schema.fromPartial(object.schema)
        : undefined;
    message.reference =
      object.reference !== undefined && object.reference !== null
        ? Reference.fromPartial(object.reference)
        : undefined;
    return message;
  }
};

function createBaseSchemasOrReferences(): SchemasOrReferences {
  return { additionalProperties: [] };
}

export const SchemasOrReferences: MessageFns<SchemasOrReferences> = {
  encode(
    message: SchemasOrReferences,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedSchemaOrReference.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): SchemasOrReferences {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemasOrReferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedSchemaOrReference.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemasOrReferences {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) =>
            NamedSchemaOrReference.fromJSON(e)
          )
        : []
    };
  },

  toJSON(message: SchemasOrReferences): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedSchemaOrReference.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SchemasOrReferences>, I>>(
    base?: I
  ): SchemasOrReferences {
    return SchemasOrReferences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SchemasOrReferences>, I>>(
    object: I
  ): SchemasOrReferences {
    const message = createBaseSchemasOrReferences();
    message.additionalProperties =
      object.additionalProperties?.map(e =>
        NamedSchemaOrReference.fromPartial(e)
      ) || [];
    return message;
  }
};

function createBaseSecurityRequirement(): SecurityRequirement {
  return { additionalProperties: [] };
}

export const SecurityRequirement: MessageFns<SecurityRequirement> = {
  encode(
    message: SecurityRequirement,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedStringArray.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): SecurityRequirement {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityRequirement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedStringArray.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecurityRequirement {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) =>
            NamedStringArray.fromJSON(e)
          )
        : []
    };
  },

  toJSON(message: SecurityRequirement): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedStringArray.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityRequirement>, I>>(
    base?: I
  ): SecurityRequirement {
    return SecurityRequirement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityRequirement>, I>>(
    object: I
  ): SecurityRequirement {
    const message = createBaseSecurityRequirement();
    message.additionalProperties =
      object.additionalProperties?.map(e => NamedStringArray.fromPartial(e)) ||
      [];
    return message;
  }
};

function createBaseSecurityScheme(): SecurityScheme {
  return {
    type: "",
    description: "",
    name: "",
    in: "",
    scheme: "",
    bearerFormat: "",
    flows: undefined,
    openIdConnectUrl: "",
    specificationExtension: []
  };
}

export const SecurityScheme: MessageFns<SecurityScheme> = {
  encode(
    message: SecurityScheme,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.in !== "") {
      writer.uint32(34).string(message.in);
    }
    if (message.scheme !== "") {
      writer.uint32(42).string(message.scheme);
    }
    if (message.bearerFormat !== "") {
      writer.uint32(50).string(message.bearerFormat);
    }
    if (message.flows !== undefined) {
      OauthFlows.encode(message.flows, writer.uint32(58).fork()).join();
    }
    if (message.openIdConnectUrl !== "") {
      writer.uint32(66).string(message.openIdConnectUrl);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecurityScheme {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityScheme();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.in = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scheme = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bearerFormat = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.flows = OauthFlows.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.openIdConnectUrl = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecurityScheme {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      in: isSet(object.in) ? globalThis.String(object.in) : "",
      scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : "",
      bearerFormat: isSet(object.bearerFormat)
        ? globalThis.String(object.bearerFormat)
        : "",
      flows: isSet(object.flows)
        ? OauthFlows.fromJSON(object.flows)
        : undefined,
      openIdConnectUrl: isSet(object.openIdConnectUrl)
        ? globalThis.String(object.openIdConnectUrl)
        : "",
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: SecurityScheme): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.in !== "") {
      obj.in = message.in;
    }
    if (message.scheme !== "") {
      obj.scheme = message.scheme;
    }
    if (message.bearerFormat !== "") {
      obj.bearerFormat = message.bearerFormat;
    }
    if (message.flows !== undefined) {
      obj.flows = OauthFlows.toJSON(message.flows);
    }
    if (message.openIdConnectUrl !== "") {
      obj.openIdConnectUrl = message.openIdConnectUrl;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityScheme>, I>>(
    base?: I
  ): SecurityScheme {
    return SecurityScheme.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityScheme>, I>>(
    object: I
  ): SecurityScheme {
    const message = createBaseSecurityScheme();
    message.type = object.type ?? "";
    message.description = object.description ?? "";
    message.name = object.name ?? "";
    message.in = object.in ?? "";
    message.scheme = object.scheme ?? "";
    message.bearerFormat = object.bearerFormat ?? "";
    message.flows =
      object.flows !== undefined && object.flows !== null
        ? OauthFlows.fromPartial(object.flows)
        : undefined;
    message.openIdConnectUrl = object.openIdConnectUrl ?? "";
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseSecuritySchemeOrReference(): SecuritySchemeOrReference {
  return { securityScheme: undefined, reference: undefined };
}

export const SecuritySchemeOrReference: MessageFns<SecuritySchemeOrReference> =
  {
    encode(
      message: SecuritySchemeOrReference,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.securityScheme !== undefined) {
        SecurityScheme.encode(
          message.securityScheme,
          writer.uint32(10).fork()
        ).join();
      }
      if (message.reference !== undefined) {
        Reference.encode(message.reference, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): SecuritySchemeOrReference {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSecuritySchemeOrReference();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.securityScheme = SecurityScheme.decode(
              reader,
              reader.uint32()
            );
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.reference = Reference.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SecuritySchemeOrReference {
      return {
        securityScheme: isSet(object.securityScheme)
          ? SecurityScheme.fromJSON(object.securityScheme)
          : undefined,
        reference: isSet(object.reference)
          ? Reference.fromJSON(object.reference)
          : undefined
      };
    },

    toJSON(message: SecuritySchemeOrReference): unknown {
      const obj: any = {};
      if (message.securityScheme !== undefined) {
        obj.securityScheme = SecurityScheme.toJSON(message.securityScheme);
      }
      if (message.reference !== undefined) {
        obj.reference = Reference.toJSON(message.reference);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<SecuritySchemeOrReference>, I>>(
      base?: I
    ): SecuritySchemeOrReference {
      return SecuritySchemeOrReference.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<SecuritySchemeOrReference>, I>>(
      object: I
    ): SecuritySchemeOrReference {
      const message = createBaseSecuritySchemeOrReference();
      message.securityScheme =
        object.securityScheme !== undefined && object.securityScheme !== null
          ? SecurityScheme.fromPartial(object.securityScheme)
          : undefined;
      message.reference =
        object.reference !== undefined && object.reference !== null
          ? Reference.fromPartial(object.reference)
          : undefined;
      return message;
    }
  };

function createBaseSecuritySchemesOrReferences(): SecuritySchemesOrReferences {
  return { additionalProperties: [] };
}

export const SecuritySchemesOrReferences: MessageFns<SecuritySchemesOrReferences> =
  {
    encode(
      message: SecuritySchemesOrReferences,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      for (const v of message.additionalProperties) {
        NamedSecuritySchemeOrReference.encode(
          v!,
          writer.uint32(10).fork()
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): SecuritySchemesOrReferences {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSecuritySchemesOrReferences();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.additionalProperties.push(
              NamedSecuritySchemeOrReference.decode(reader, reader.uint32())
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SecuritySchemesOrReferences {
      return {
        additionalProperties: globalThis.Array.isArray(
          object?.additionalProperties
        )
          ? object.additionalProperties.map((e: any) =>
              NamedSecuritySchemeOrReference.fromJSON(e)
            )
          : []
      };
    },

    toJSON(message: SecuritySchemesOrReferences): unknown {
      const obj: any = {};
      if (message.additionalProperties?.length) {
        obj.additionalProperties = message.additionalProperties.map(e =>
          NamedSecuritySchemeOrReference.toJSON(e)
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<SecuritySchemesOrReferences>, I>>(
      base?: I
    ): SecuritySchemesOrReferences {
      return SecuritySchemesOrReferences.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<SecuritySchemesOrReferences>, I>>(
      object: I
    ): SecuritySchemesOrReferences {
      const message = createBaseSecuritySchemesOrReferences();
      message.additionalProperties =
        object.additionalProperties?.map(e =>
          NamedSecuritySchemeOrReference.fromPartial(e)
        ) || [];
      return message;
    }
  };

function createBaseServer(): Server {
  return {
    url: "",
    description: "",
    variables: undefined,
    specificationExtension: []
  };
}

export const Server: MessageFns<Server> = {
  encode(
    message: Server,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.variables !== undefined) {
      ServerVariables.encode(
        message.variables,
        writer.uint32(26).fork()
      ).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Server {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.variables = ServerVariables.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Server {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      variables: isSet(object.variables)
        ? ServerVariables.fromJSON(object.variables)
        : undefined,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Server): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.variables !== undefined) {
      obj.variables = ServerVariables.toJSON(message.variables);
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Server>, I>>(base?: I): Server {
    return Server.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Server>, I>>(object: I): Server {
    const message = createBaseServer();
    message.url = object.url ?? "";
    message.description = object.description ?? "";
    message.variables =
      object.variables !== undefined && object.variables !== null
        ? ServerVariables.fromPartial(object.variables)
        : undefined;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseServerVariable(): ServerVariable {
  return { enum: [], default: "", description: "", specificationExtension: [] };
}

export const ServerVariable: MessageFns<ServerVariable> = {
  encode(
    message: ServerVariable,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.enum) {
      writer.uint32(10).string(v!);
    }
    if (message.default !== "") {
      writer.uint32(18).string(message.default);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerVariable {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.enum.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.default = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerVariable {
    return {
      enum: globalThis.Array.isArray(object?.enum)
        ? object.enum.map((e: any) => globalThis.String(e))
        : [],
      default: isSet(object.default) ? globalThis.String(object.default) : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: ServerVariable): unknown {
    const obj: any = {};
    if (message.enum?.length) {
      obj.enum = message.enum;
    }
    if (message.default !== "") {
      obj.default = message.default;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerVariable>, I>>(
    base?: I
  ): ServerVariable {
    return ServerVariable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerVariable>, I>>(
    object: I
  ): ServerVariable {
    const message = createBaseServerVariable();
    message.enum = object.enum?.map(e => e) || [];
    message.default = object.default ?? "";
    message.description = object.description ?? "";
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseServerVariables(): ServerVariables {
  return { additionalProperties: [] };
}

export const ServerVariables: MessageFns<ServerVariables> = {
  encode(
    message: ServerVariables,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedServerVariable.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerVariables {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerVariables();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedServerVariable.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerVariables {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) =>
            NamedServerVariable.fromJSON(e)
          )
        : []
    };
  },

  toJSON(message: ServerVariables): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedServerVariable.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerVariables>, I>>(
    base?: I
  ): ServerVariables {
    return ServerVariables.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerVariables>, I>>(
    object: I
  ): ServerVariables {
    const message = createBaseServerVariables();
    message.additionalProperties =
      object.additionalProperties?.map(e =>
        NamedServerVariable.fromPartial(e)
      ) || [];
    return message;
  }
};

function createBaseSpecificationExtension(): SpecificationExtension {
  return { number: undefined, boolean: undefined, string: undefined };
}

export const SpecificationExtension: MessageFns<SpecificationExtension> = {
  encode(
    message: SpecificationExtension,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.number !== undefined) {
      writer.uint32(9).double(message.number);
    }
    if (message.boolean !== undefined) {
      writer.uint32(16).bool(message.boolean);
    }
    if (message.string !== undefined) {
      writer.uint32(26).string(message.string);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): SpecificationExtension {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpecificationExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.number = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.boolean = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.string = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpecificationExtension {
    return {
      number: isSet(object.number)
        ? globalThis.Number(object.number)
        : undefined,
      boolean: isSet(object.boolean)
        ? globalThis.Boolean(object.boolean)
        : undefined,
      string: isSet(object.string)
        ? globalThis.String(object.string)
        : undefined
    };
  },

  toJSON(message: SpecificationExtension): unknown {
    const obj: any = {};
    if (message.number !== undefined) {
      obj.number = message.number;
    }
    if (message.boolean !== undefined) {
      obj.boolean = message.boolean;
    }
    if (message.string !== undefined) {
      obj.string = message.string;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpecificationExtension>, I>>(
    base?: I
  ): SpecificationExtension {
    return SpecificationExtension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpecificationExtension>, I>>(
    object: I
  ): SpecificationExtension {
    const message = createBaseSpecificationExtension();
    message.number = object.number ?? undefined;
    message.boolean = object.boolean ?? undefined;
    message.string = object.string ?? undefined;
    return message;
  }
};

function createBaseStringArray(): StringArray {
  return { value: [] };
}

export const StringArray: MessageFns<StringArray> = {
  encode(
    message: StringArray,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.value) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringArray {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringArray {
    return {
      value: globalThis.Array.isArray(object?.value)
        ? object.value.map((e: any) => globalThis.String(e))
        : []
    };
  },

  toJSON(message: StringArray): unknown {
    const obj: any = {};
    if (message.value?.length) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StringArray>, I>>(base?: I): StringArray {
    return StringArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StringArray>, I>>(
    object: I
  ): StringArray {
    const message = createBaseStringArray();
    message.value = object.value?.map(e => e) || [];
    return message;
  }
};

function createBaseStrings(): Strings {
  return { additionalProperties: [] };
}

export const Strings: MessageFns<Strings> = {
  encode(
    message: Strings,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedString.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Strings {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedString.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Strings {
    return {
      additionalProperties: globalThis.Array.isArray(
        object?.additionalProperties
      )
        ? object.additionalProperties.map((e: any) => NamedString.fromJSON(e))
        : []
    };
  },

  toJSON(message: Strings): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map(e =>
        NamedString.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Strings>, I>>(base?: I): Strings {
    return Strings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Strings>, I>>(object: I): Strings {
    const message = createBaseStrings();
    message.additionalProperties =
      object.additionalProperties?.map(e => NamedString.fromPartial(e)) || [];
    return message;
  }
};

function createBaseTag(): Tag {
  return {
    name: "",
    description: "",
    externalDocs: undefined,
    specificationExtension: []
  };
}

export const Tag: MessageFns<Tag> = {
  encode(
    message: Tag,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.externalDocs !== undefined) {
      ExternalDocs.encode(
        message.externalDocs,
        writer.uint32(26).fork()
      ).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tag {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.externalDocs = ExternalDocs.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tag {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      externalDocs: isSet(object.externalDocs)
        ? ExternalDocs.fromJSON(object.externalDocs)
        : undefined,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Tag): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.externalDocs !== undefined) {
      obj.externalDocs = ExternalDocs.toJSON(message.externalDocs);
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tag>, I>>(base?: I): Tag {
    return Tag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tag>, I>>(object: I): Tag {
    const message = createBaseTag();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.externalDocs =
      object.externalDocs !== undefined && object.externalDocs !== null
        ? ExternalDocs.fromPartial(object.externalDocs)
        : undefined;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

function createBaseXml(): Xml {
  return {
    name: "",
    namespace: "",
    prefix: "",
    attribute: false,
    wrapped: false,
    specificationExtension: []
  };
}

export const Xml: MessageFns<Xml> = {
  encode(
    message: Xml,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.prefix !== "") {
      writer.uint32(26).string(message.prefix);
    }
    if (message.attribute !== false) {
      writer.uint32(32).bool(message.attribute);
    }
    if (message.wrapped !== false) {
      writer.uint32(40).bool(message.wrapped);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Xml {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXml();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.attribute = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.wrapped = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32())
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Xml {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace)
        ? globalThis.String(object.namespace)
        : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
      attribute: isSet(object.attribute)
        ? globalThis.Boolean(object.attribute)
        : false,
      wrapped: isSet(object.wrapped)
        ? globalThis.Boolean(object.wrapped)
        : false,
      specificationExtension: globalThis.Array.isArray(
        object?.specificationExtension
      )
        ? object.specificationExtension.map((e: any) => NamedAny.fromJSON(e))
        : []
    };
  },

  toJSON(message: Xml): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    if (message.attribute !== false) {
      obj.attribute = message.attribute;
    }
    if (message.wrapped !== false) {
      obj.wrapped = message.wrapped;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map(e =>
        NamedAny.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Xml>, I>>(base?: I): Xml {
    return Xml.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Xml>, I>>(object: I): Xml {
    const message = createBaseXml();
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    message.prefix = object.prefix ?? "";
    message.attribute = object.attribute ?? false;
    message.wrapped = object.wrapped ?? false;
    message.specificationExtension =
      object.specificationExtension?.map(e => NamedAny.fromPartial(e)) || [];
    return message;
  }
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
