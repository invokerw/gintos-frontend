// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.14.0
// source: v1/auth/auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty } from "../../google/protobuf/empty";
import { User } from "../common/user";

export const protobufPackage = "api.auth.v1";

/** 验证密码结果码 */
export enum VerifyPasswordResult {
  /** SUCCESS - 验证成功 */
  SUCCESS = 0,
  /** ACCOUNT_NOT_EXISTS - 账号不存在 */
  ACCOUNT_NOT_EXISTS = 1,
  /** WRONG_PASSWORD - 密码错误 */
  WRONG_PASSWORD = 2,
  /** FREEZE - 已冻结 */
  FREEZE = 3,
  /** DELETED - 已删除 */
  DELETED = 4,
  UNRECOGNIZED = -1
}

export function verifyPasswordResultFromJSON(
  object: any
): VerifyPasswordResult {
  switch (object) {
    case 0:
    case "SUCCESS":
      return VerifyPasswordResult.SUCCESS;
    case 1:
    case "ACCOUNT_NOT_EXISTS":
      return VerifyPasswordResult.ACCOUNT_NOT_EXISTS;
    case 2:
    case "WRONG_PASSWORD":
      return VerifyPasswordResult.WRONG_PASSWORD;
    case 3:
    case "FREEZE":
      return VerifyPasswordResult.FREEZE;
    case 4:
    case "DELETED":
      return VerifyPasswordResult.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VerifyPasswordResult.UNRECOGNIZED;
  }
}

export function verifyPasswordResultToJSON(
  object: VerifyPasswordResult
): string {
  switch (object) {
    case VerifyPasswordResult.SUCCESS:
      return "SUCCESS";
    case VerifyPasswordResult.ACCOUNT_NOT_EXISTS:
      return "ACCOUNT_NOT_EXISTS";
    case VerifyPasswordResult.WRONG_PASSWORD:
      return "WRONG_PASSWORD";
    case VerifyPasswordResult.FREEZE:
      return "FREEZE";
    case VerifyPasswordResult.DELETED:
      return "DELETED";
    case VerifyPasswordResult.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RegisterRequest {
  /** 用户名，必选项。 */
  username: string;
  /** 用户的密码，必选项。 */
  password: string;
  /** 用户的邮箱，必选项。 */
  email: string;
}

/** 用户后台登出 - 请求 */
export interface LogoutRequest {
  id: number;
}

/** 用户后台登录 - 请求 */
export interface LoginRequest {
  /** 用户名，必选项。 */
  username: string;
  /** 用户的密码，必选项。 */
  password: string;
}

/** 用户后台登录 - 回应 */
export interface LoginResponse {
  /** 用户信息 */
  user: User | undefined;
  /** 访问令牌 */
  accessToken: string;
  /** 更新令牌，用来获取下一次的访问令牌，可选项。 */
  refreshToken: string;
  expires: number;
  refreshExpires: number;
}

/** 用户刷新令牌 - 请求 */
export interface RefreshTokenRequest {
  /** 更新令牌，用来获取下一次的访问令牌，必选项。 */
  refreshToken: string;
}

/** 用户刷新令牌 - 回应 */
export interface RefreshTokenResponse {
  /** 用户信息，必选项。 */
  user: User | undefined;
  /** 访问令牌，必选项。 */
  accessToken: string;
  /** 更新令牌，用来获取下一次的访问令牌，可选项。 */
  refreshToken: string;
  expires: number;
  refreshExpires: number;
}

export interface GetAsyncRoutesResponse {
  /** 异步路由列表 */
  routes: RouteConfig[];
}

/** 定义路由元信息 */
export interface RouteMeta {
  /** 菜单名称 */
  title: string;
  /** 菜单图标 */
  icon: string;
  /** 菜单排序 */
  rank: number;
  /** 是否在菜单中显示 */
  showLink: boolean;
  /** 页面级别权限设置 */
  roles: string[];
  /** 按钮级别权限设置 */
  auths: string[];
}

/** 定义路由配置表 */
export interface RouteConfig {
  /** 路由路径 */
  path: string;
  /** 路由名称（必须保持唯一） */
  name: string;
  /** 重定向路径 */
  redirect: string;
  /** 路由元信息 */
  meta: RouteMeta | undefined;
  /** 按需加载需要展示的页面 */
  component: string;
  /** 子路由配置项 */
  children: RouteConfig[];
}

function createBaseRegisterRequest(): RegisterRequest {
  return { username: "", password: "", email: "" };
}

export const RegisterRequest: MessageFns<RegisterRequest> = {
  encode(
    message: RegisterRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterRequest {
    return {
      username: isSet(object.username)
        ? globalThis.String(object.username)
        : "",
      password: isSet(object.password)
        ? globalThis.String(object.password)
        : "",
      email: isSet(object.email) ? globalThis.String(object.email) : ""
    };
  },

  toJSON(message: RegisterRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterRequest>, I>>(
    base?: I
  ): RegisterRequest {
    return RegisterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterRequest>, I>>(
    object: I
  ): RegisterRequest {
    const message = createBaseRegisterRequest();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.email = object.email ?? "";
    return message;
  }
};

function createBaseLogoutRequest(): LogoutRequest {
  return { id: 0 };
}

export const LogoutRequest: MessageFns<LogoutRequest> = {
  encode(
    message: LogoutRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: LogoutRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutRequest>, I>>(
    base?: I
  ): LogoutRequest {
    return LogoutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutRequest>, I>>(
    object: I
  ): LogoutRequest {
    const message = createBaseLogoutRequest();
    message.id = object.id ?? 0;
    return message;
  }
};

function createBaseLoginRequest(): LoginRequest {
  return { username: "", password: "" };
}

export const LoginRequest: MessageFns<LoginRequest> = {
  encode(
    message: LoginRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequest {
    return {
      username: isSet(object.username)
        ? globalThis.String(object.username)
        : "",
      password: isSet(object.password) ? globalThis.String(object.password) : ""
    };
  },

  toJSON(message: LoginRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequest>, I>>(
    base?: I
  ): LoginRequest {
    return LoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequest>, I>>(
    object: I
  ): LoginRequest {
    const message = createBaseLoginRequest();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  }
};

function createBaseLoginResponse(): LoginResponse {
  return {
    user: undefined,
    accessToken: "",
    refreshToken: "",
    expires: 0,
    refreshExpires: 0
  };
}

export const LoginResponse: MessageFns<LoginResponse> = {
  encode(
    message: LoginResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.expires !== 0) {
      writer.uint32(32).int64(message.expires);
    }
    if (message.refreshExpires !== 0) {
      writer.uint32(40).int64(message.refreshExpires);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expires = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.refreshExpires = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginResponse {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      accessToken: isSet(object.access_token)
        ? globalThis.String(object.access_token)
        : "",
      refreshToken: isSet(object.refresh_token)
        ? globalThis.String(object.refresh_token)
        : "",
      expires: isSet(object.expires) ? globalThis.Number(object.expires) : 0,
      refreshExpires: isSet(object.refresh_expires)
        ? globalThis.Number(object.refresh_expires)
        : 0
    };
  },

  toJSON(message: LoginResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.accessToken !== "") {
      obj.access_token = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refresh_token = message.refreshToken;
    }
    if (message.expires !== 0) {
      obj.expires = Math.round(message.expires);
    }
    if (message.refreshExpires !== 0) {
      obj.refresh_expires = Math.round(message.refreshExpires);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginResponse>, I>>(
    base?: I
  ): LoginResponse {
    return LoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginResponse>, I>>(
    object: I
  ): LoginResponse {
    const message = createBaseLoginResponse();
    message.user =
      object.user !== undefined && object.user !== null
        ? User.fromPartial(object.user)
        : undefined;
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.expires = object.expires ?? 0;
    message.refreshExpires = object.refreshExpires ?? 0;
    return message;
  }
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { refreshToken: "" };
}

export const RefreshTokenRequest: MessageFns<RefreshTokenRequest> = {
  encode(
    message: RefreshTokenRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): RefreshTokenRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenRequest {
    return {
      refreshToken: isSet(object.refresh_token)
        ? globalThis.String(object.refresh_token)
        : ""
    };
  },

  toJSON(message: RefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refresh_token = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(
    base?: I
  ): RefreshTokenRequest {
    return RefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(
    object: I
  ): RefreshTokenRequest {
    const message = createBaseRefreshTokenRequest();
    message.refreshToken = object.refreshToken ?? "";
    return message;
  }
};

function createBaseRefreshTokenResponse(): RefreshTokenResponse {
  return {
    user: undefined,
    accessToken: "",
    refreshToken: "",
    expires: 0,
    refreshExpires: 0
  };
}

export const RefreshTokenResponse: MessageFns<RefreshTokenResponse> = {
  encode(
    message: RefreshTokenResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.expires !== 0) {
      writer.uint32(32).int64(message.expires);
    }
    if (message.refreshExpires !== 0) {
      writer.uint32(40).int64(message.refreshExpires);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): RefreshTokenResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expires = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.refreshExpires = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenResponse {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      accessToken: isSet(object.access_token)
        ? globalThis.String(object.access_token)
        : "",
      refreshToken: isSet(object.refresh_token)
        ? globalThis.String(object.refresh_token)
        : "",
      expires: isSet(object.expires) ? globalThis.Number(object.expires) : 0,
      refreshExpires: isSet(object.refresh_expires)
        ? globalThis.Number(object.refresh_expires)
        : 0
    };
  },

  toJSON(message: RefreshTokenResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.accessToken !== "") {
      obj.access_token = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refresh_token = message.refreshToken;
    }
    if (message.expires !== 0) {
      obj.expires = Math.round(message.expires);
    }
    if (message.refreshExpires !== 0) {
      obj.refresh_expires = Math.round(message.refreshExpires);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(
    base?: I
  ): RefreshTokenResponse {
    return RefreshTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(
    object: I
  ): RefreshTokenResponse {
    const message = createBaseRefreshTokenResponse();
    message.user =
      object.user !== undefined && object.user !== null
        ? User.fromPartial(object.user)
        : undefined;
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.expires = object.expires ?? 0;
    message.refreshExpires = object.refreshExpires ?? 0;
    return message;
  }
};

function createBaseGetAsyncRoutesResponse(): GetAsyncRoutesResponse {
  return { routes: [] };
}

export const GetAsyncRoutesResponse: MessageFns<GetAsyncRoutesResponse> = {
  encode(
    message: GetAsyncRoutesResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.routes) {
      RouteConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): GetAsyncRoutesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAsyncRoutesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routes.push(RouteConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAsyncRoutesResponse {
    return {
      routes: globalThis.Array.isArray(object?.routes)
        ? object.routes.map((e: any) => RouteConfig.fromJSON(e))
        : []
    };
  },

  toJSON(message: GetAsyncRoutesResponse): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map(e => RouteConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAsyncRoutesResponse>, I>>(
    base?: I
  ): GetAsyncRoutesResponse {
    return GetAsyncRoutesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAsyncRoutesResponse>, I>>(
    object: I
  ): GetAsyncRoutesResponse {
    const message = createBaseGetAsyncRoutesResponse();
    message.routes = object.routes?.map(e => RouteConfig.fromPartial(e)) || [];
    return message;
  }
};

function createBaseRouteMeta(): RouteMeta {
  return {
    title: "",
    icon: "",
    rank: 0,
    showLink: false,
    roles: [],
    auths: []
  };
}

export const RouteMeta: MessageFns<RouteMeta> = {
  encode(
    message: RouteMeta,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.icon !== "") {
      writer.uint32(18).string(message.icon);
    }
    if (message.rank !== 0) {
      writer.uint32(24).int32(message.rank);
    }
    if (message.showLink !== false) {
      writer.uint32(32).bool(message.showLink);
    }
    for (const v of message.roles) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.auths) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteMeta {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.icon = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rank = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.showLink = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.roles.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.auths.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteMeta {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      icon: isSet(object.icon) ? globalThis.String(object.icon) : "",
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      showLink: isSet(object.showLink)
        ? globalThis.Boolean(object.showLink)
        : false,
      roles: globalThis.Array.isArray(object?.roles)
        ? object.roles.map((e: any) => globalThis.String(e))
        : [],
      auths: globalThis.Array.isArray(object?.auths)
        ? object.auths.map((e: any) => globalThis.String(e))
        : []
    };
  },

  toJSON(message: RouteMeta): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    if (message.rank !== 0) {
      obj.rank = Math.round(message.rank);
    }
    if (message.showLink !== false) {
      obj.showLink = message.showLink;
    }
    if (message.roles?.length) {
      obj.roles = message.roles;
    }
    if (message.auths?.length) {
      obj.auths = message.auths;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteMeta>, I>>(base?: I): RouteMeta {
    return RouteMeta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteMeta>, I>>(
    object: I
  ): RouteMeta {
    const message = createBaseRouteMeta();
    message.title = object.title ?? "";
    message.icon = object.icon ?? "";
    message.rank = object.rank ?? 0;
    message.showLink = object.showLink ?? false;
    message.roles = object.roles?.map(e => e) || [];
    message.auths = object.auths?.map(e => e) || [];
    return message;
  }
};

function createBaseRouteConfig(): RouteConfig {
  return {
    path: "",
    name: "",
    redirect: "",
    meta: undefined,
    component: "",
    children: []
  };
}

export const RouteConfig: MessageFns<RouteConfig> = {
  encode(
    message: RouteConfig,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.redirect !== "") {
      writer.uint32(26).string(message.redirect);
    }
    if (message.meta !== undefined) {
      RouteMeta.encode(message.meta, writer.uint32(34).fork()).join();
    }
    if (message.component !== "") {
      writer.uint32(42).string(message.component);
    }
    for (const v of message.children) {
      RouteConfig.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteConfig {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.redirect = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.meta = RouteMeta.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.component = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.children.push(RouteConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteConfig {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      redirect: isSet(object.redirect)
        ? globalThis.String(object.redirect)
        : "",
      meta: isSet(object.meta) ? RouteMeta.fromJSON(object.meta) : undefined,
      component: isSet(object.component)
        ? globalThis.String(object.component)
        : "",
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => RouteConfig.fromJSON(e))
        : []
    };
  },

  toJSON(message: RouteConfig): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.redirect !== "") {
      obj.redirect = message.redirect;
    }
    if (message.meta !== undefined) {
      obj.meta = RouteMeta.toJSON(message.meta);
    }
    if (message.component !== "") {
      obj.component = message.component;
    }
    if (message.children?.length) {
      obj.children = message.children.map(e => RouteConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteConfig>, I>>(base?: I): RouteConfig {
    return RouteConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteConfig>, I>>(
    object: I
  ): RouteConfig {
    const message = createBaseRouteConfig();
    message.path = object.path ?? "";
    message.name = object.name ?? "";
    message.redirect = object.redirect ?? "";
    message.meta =
      object.meta !== undefined && object.meta !== null
        ? RouteMeta.fromPartial(object.meta)
        : undefined;
    message.component = object.component ?? "";
    message.children =
      object.children?.map(e => RouteConfig.fromPartial(e)) || [];
    return message;
  }
};

export interface Auth {
  /** 登录 */
  Login(request: LoginRequest): Promise<LoginResponse>;
  /** 登出 */
  Logout(request: LogoutRequest): Promise<Empty>;
  Register(request: RegisterRequest): Promise<Empty>;
  /** 刷新认证令牌 */
  RefreshToken(request: RefreshTokenRequest): Promise<RefreshTokenResponse>;
  GetAsyncRoutes(request: Empty): Promise<GetAsyncRoutesResponse>;
}

export const AuthServiceName = "api.auth.v1.Auth";
export class AuthClientImpl implements Auth {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AuthServiceName;
    this.rpc = rpc;
    this.Login = this.Login.bind(this);
    this.Logout = this.Logout.bind(this);
    this.Register = this.Register.bind(this);
    this.RefreshToken = this.RefreshToken.bind(this);
    this.GetAsyncRoutes = this.GetAsyncRoutes.bind(this);
  }
  Login(request: LoginRequest): Promise<LoginResponse> {
    const data = LoginRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Login", data);
    return promise.then(data => LoginResponse.decode(new BinaryReader(data)));
  }

  Logout(request: LogoutRequest): Promise<Empty> {
    const data = LogoutRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Logout", data);
    return promise.then(data => Empty.decode(new BinaryReader(data)));
  }

  Register(request: RegisterRequest): Promise<Empty> {
    const data = RegisterRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Register", data);
    return promise.then(data => Empty.decode(new BinaryReader(data)));
  }

  RefreshToken(request: RefreshTokenRequest): Promise<RefreshTokenResponse> {
    const data = RefreshTokenRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RefreshToken", data);
    return promise.then(data =>
      RefreshTokenResponse.decode(new BinaryReader(data))
    );
  }

  GetAsyncRoutes(request: Empty): Promise<GetAsyncRoutesResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAsyncRoutes", data);
    return promise.then(data =>
      GetAsyncRoutesResponse.decode(new BinaryReader(data))
    );
  }
}

interface Rpc {
  request(
    service: string,
    method: string,
    data: Uint8Array
  ): Promise<Uint8Array>;
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
